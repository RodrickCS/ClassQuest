
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model alunos
 * 
 */
export type alunos = {
  id_aluno: number
  nome: string
  email: string
  senha: string
  nivel_de_acesso: string | null
}

/**
 * Model professores
 * 
 */
export type professores = {
  id_prof: number
  nome: string
  email: string
  senha: string
  nivel_de_acesso: string | null
}

/**
 * Model atividades
 * 
 */
export type atividades = {
  id_atividade: number
  id_turma: number
  titulo: string
  descricao: string
  prazo: Date
  pontos_conclusao: number
}

/**
 * Model atividades_concluidas
 * 
 */
export type atividades_concluidas = {
  id_concluida: number
  id_atividade: number
  id_aluno: number
  data_concluida: Date
  arquivo: string
}

/**
 * Model turmas
 * 
 */
export type turmas = {
  id_turma: number
  nome: string
  codigo: string
}

/**
 * Model premios
 * 
 */
export type premios = {
  id_premio: number
  id_turma: number
  descricao: string
  pontos_requeridos: number
}

/**
 * Model pontos
 * 
 */
export type pontos = {
  id_ponto: number
  id_aluno: number
  id_turma: number
  qtd: number | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Alunos
 * const alunos = await prisma.alunos.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Alunos
   * const alunos = await prisma.alunos.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.alunos`: Exposes CRUD operations for the **alunos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alunos
    * const alunos = await prisma.alunos.findMany()
    * ```
    */
  get alunos(): Prisma.alunosDelegate<GlobalReject>;

  /**
   * `prisma.professores`: Exposes CRUD operations for the **professores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Professores
    * const professores = await prisma.professores.findMany()
    * ```
    */
  get professores(): Prisma.professoresDelegate<GlobalReject>;

  /**
   * `prisma.atividades`: Exposes CRUD operations for the **atividades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Atividades
    * const atividades = await prisma.atividades.findMany()
    * ```
    */
  get atividades(): Prisma.atividadesDelegate<GlobalReject>;

  /**
   * `prisma.atividades_concluidas`: Exposes CRUD operations for the **atividades_concluidas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Atividades_concluidas
    * const atividades_concluidas = await prisma.atividades_concluidas.findMany()
    * ```
    */
  get atividades_concluidas(): Prisma.atividades_concluidasDelegate<GlobalReject>;

  /**
   * `prisma.turmas`: Exposes CRUD operations for the **turmas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Turmas
    * const turmas = await prisma.turmas.findMany()
    * ```
    */
  get turmas(): Prisma.turmasDelegate<GlobalReject>;

  /**
   * `prisma.premios`: Exposes CRUD operations for the **premios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Premios
    * const premios = await prisma.premios.findMany()
    * ```
    */
  get premios(): Prisma.premiosDelegate<GlobalReject>;

  /**
   * `prisma.pontos`: Exposes CRUD operations for the **pontos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pontos
    * const pontos = await prisma.pontos.findMany()
    * ```
    */
  get pontos(): Prisma.pontosDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.11.0
   * Query Engine version: d9a4c5988f480fa576d43970d5a23641aa77bc9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    alunos: 'alunos',
    professores: 'professores',
    atividades: 'atividades',
    atividades_concluidas: 'atividades_concluidas',
    turmas: 'turmas',
    premios: 'premios',
    pontos: 'pontos'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AlunosCountOutputType
   */


  export type AlunosCountOutputType = {
    turma: number
    pontos: number
    atividades_concluidas: number
  }

  export type AlunosCountOutputTypeSelect = {
    turma?: boolean
    pontos?: boolean
    atividades_concluidas?: boolean
  }

  export type AlunosCountOutputTypeGetPayload<S extends boolean | null | undefined | AlunosCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AlunosCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AlunosCountOutputTypeArgs)
    ? AlunosCountOutputType 
    : S extends { select: any } & (AlunosCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AlunosCountOutputType ? AlunosCountOutputType[P] : never
  } 
      : AlunosCountOutputType




  // Custom InputTypes

  /**
   * AlunosCountOutputType without action
   */
  export type AlunosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AlunosCountOutputType
     */
    select?: AlunosCountOutputTypeSelect | null
  }



  /**
   * Count Type ProfessoresCountOutputType
   */


  export type ProfessoresCountOutputType = {
    turma: number
  }

  export type ProfessoresCountOutputTypeSelect = {
    turma?: boolean
  }

  export type ProfessoresCountOutputTypeGetPayload<S extends boolean | null | undefined | ProfessoresCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProfessoresCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProfessoresCountOutputTypeArgs)
    ? ProfessoresCountOutputType 
    : S extends { select: any } & (ProfessoresCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProfessoresCountOutputType ? ProfessoresCountOutputType[P] : never
  } 
      : ProfessoresCountOutputType




  // Custom InputTypes

  /**
   * ProfessoresCountOutputType without action
   */
  export type ProfessoresCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProfessoresCountOutputType
     */
    select?: ProfessoresCountOutputTypeSelect | null
  }



  /**
   * Count Type AtividadesCountOutputType
   */


  export type AtividadesCountOutputType = {
    atividades_concluidas: number
  }

  export type AtividadesCountOutputTypeSelect = {
    atividades_concluidas?: boolean
  }

  export type AtividadesCountOutputTypeGetPayload<S extends boolean | null | undefined | AtividadesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AtividadesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AtividadesCountOutputTypeArgs)
    ? AtividadesCountOutputType 
    : S extends { select: any } & (AtividadesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AtividadesCountOutputType ? AtividadesCountOutputType[P] : never
  } 
      : AtividadesCountOutputType




  // Custom InputTypes

  /**
   * AtividadesCountOutputType without action
   */
  export type AtividadesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AtividadesCountOutputType
     */
    select?: AtividadesCountOutputTypeSelect | null
  }



  /**
   * Count Type TurmasCountOutputType
   */


  export type TurmasCountOutputType = {
    professores: number
    alunos: number
    atividades: number
    pontos: number
    premios: number
  }

  export type TurmasCountOutputTypeSelect = {
    professores?: boolean
    alunos?: boolean
    atividades?: boolean
    pontos?: boolean
    premios?: boolean
  }

  export type TurmasCountOutputTypeGetPayload<S extends boolean | null | undefined | TurmasCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TurmasCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TurmasCountOutputTypeArgs)
    ? TurmasCountOutputType 
    : S extends { select: any } & (TurmasCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TurmasCountOutputType ? TurmasCountOutputType[P] : never
  } 
      : TurmasCountOutputType




  // Custom InputTypes

  /**
   * TurmasCountOutputType without action
   */
  export type TurmasCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TurmasCountOutputType
     */
    select?: TurmasCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model alunos
   */


  export type AggregateAlunos = {
    _count: AlunosCountAggregateOutputType | null
    _avg: AlunosAvgAggregateOutputType | null
    _sum: AlunosSumAggregateOutputType | null
    _min: AlunosMinAggregateOutputType | null
    _max: AlunosMaxAggregateOutputType | null
  }

  export type AlunosAvgAggregateOutputType = {
    id_aluno: number | null
  }

  export type AlunosSumAggregateOutputType = {
    id_aluno: number | null
  }

  export type AlunosMinAggregateOutputType = {
    id_aluno: number | null
    nome: string | null
    email: string | null
    senha: string | null
    nivel_de_acesso: string | null
  }

  export type AlunosMaxAggregateOutputType = {
    id_aluno: number | null
    nome: string | null
    email: string | null
    senha: string | null
    nivel_de_acesso: string | null
  }

  export type AlunosCountAggregateOutputType = {
    id_aluno: number
    nome: number
    email: number
    senha: number
    nivel_de_acesso: number
    _all: number
  }


  export type AlunosAvgAggregateInputType = {
    id_aluno?: true
  }

  export type AlunosSumAggregateInputType = {
    id_aluno?: true
  }

  export type AlunosMinAggregateInputType = {
    id_aluno?: true
    nome?: true
    email?: true
    senha?: true
    nivel_de_acesso?: true
  }

  export type AlunosMaxAggregateInputType = {
    id_aluno?: true
    nome?: true
    email?: true
    senha?: true
    nivel_de_acesso?: true
  }

  export type AlunosCountAggregateInputType = {
    id_aluno?: true
    nome?: true
    email?: true
    senha?: true
    nivel_de_acesso?: true
    _all?: true
  }

  export type AlunosAggregateArgs = {
    /**
     * Filter which alunos to aggregate.
     */
    where?: alunosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alunos to fetch.
     */
    orderBy?: Enumerable<alunosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alunosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alunos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alunos
    **/
    _count?: true | AlunosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlunosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlunosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlunosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlunosMaxAggregateInputType
  }

  export type GetAlunosAggregateType<T extends AlunosAggregateArgs> = {
        [P in keyof T & keyof AggregateAlunos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlunos[P]>
      : GetScalarType<T[P], AggregateAlunos[P]>
  }




  export type AlunosGroupByArgs = {
    where?: alunosWhereInput
    orderBy?: Enumerable<alunosOrderByWithAggregationInput>
    by: AlunosScalarFieldEnum[]
    having?: alunosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlunosCountAggregateInputType | true
    _avg?: AlunosAvgAggregateInputType
    _sum?: AlunosSumAggregateInputType
    _min?: AlunosMinAggregateInputType
    _max?: AlunosMaxAggregateInputType
  }


  export type AlunosGroupByOutputType = {
    id_aluno: number
    nome: string
    email: string
    senha: string
    nivel_de_acesso: string | null
    _count: AlunosCountAggregateOutputType | null
    _avg: AlunosAvgAggregateOutputType | null
    _sum: AlunosSumAggregateOutputType | null
    _min: AlunosMinAggregateOutputType | null
    _max: AlunosMaxAggregateOutputType | null
  }

  type GetAlunosGroupByPayload<T extends AlunosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AlunosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlunosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlunosGroupByOutputType[P]>
            : GetScalarType<T[P], AlunosGroupByOutputType[P]>
        }
      >
    >


  export type alunosSelect = {
    id_aluno?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    nivel_de_acesso?: boolean
    turma?: boolean | alunos$turmaArgs
    pontos?: boolean | alunos$pontosArgs
    atividades_concluidas?: boolean | alunos$atividades_concluidasArgs
    _count?: boolean | AlunosCountOutputTypeArgs
  }


  export type alunosInclude = {
    turma?: boolean | alunos$turmaArgs
    pontos?: boolean | alunos$pontosArgs
    atividades_concluidas?: boolean | alunos$atividades_concluidasArgs
    _count?: boolean | AlunosCountOutputTypeArgs
  }

  export type alunosGetPayload<S extends boolean | null | undefined | alunosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? alunos :
    S extends undefined ? never :
    S extends { include: any } & (alunosArgs | alunosFindManyArgs)
    ? alunos  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'turma' ? Array < turmasGetPayload<S['include'][P]>>  :
        P extends 'pontos' ? Array < pontosGetPayload<S['include'][P]>>  :
        P extends 'atividades_concluidas' ? Array < atividades_concluidasGetPayload<S['include'][P]>>  :
        P extends '_count' ? AlunosCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (alunosArgs | alunosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'turma' ? Array < turmasGetPayload<S['select'][P]>>  :
        P extends 'pontos' ? Array < pontosGetPayload<S['select'][P]>>  :
        P extends 'atividades_concluidas' ? Array < atividades_concluidasGetPayload<S['select'][P]>>  :
        P extends '_count' ? AlunosCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof alunos ? alunos[P] : never
  } 
      : alunos


  type alunosCountArgs = 
    Omit<alunosFindManyArgs, 'select' | 'include'> & {
      select?: AlunosCountAggregateInputType | true
    }

  export interface alunosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Alunos that matches the filter.
     * @param {alunosFindUniqueArgs} args - Arguments to find a Alunos
     * @example
     * // Get one Alunos
     * const alunos = await prisma.alunos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends alunosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, alunosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'alunos'> extends True ? Prisma__alunosClient<alunosGetPayload<T>> : Prisma__alunosClient<alunosGetPayload<T> | null, null>

    /**
     * Find one Alunos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {alunosFindUniqueOrThrowArgs} args - Arguments to find a Alunos
     * @example
     * // Get one Alunos
     * const alunos = await prisma.alunos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends alunosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, alunosFindUniqueOrThrowArgs>
    ): Prisma__alunosClient<alunosGetPayload<T>>

    /**
     * Find the first Alunos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alunosFindFirstArgs} args - Arguments to find a Alunos
     * @example
     * // Get one Alunos
     * const alunos = await prisma.alunos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends alunosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, alunosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'alunos'> extends True ? Prisma__alunosClient<alunosGetPayload<T>> : Prisma__alunosClient<alunosGetPayload<T> | null, null>

    /**
     * Find the first Alunos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alunosFindFirstOrThrowArgs} args - Arguments to find a Alunos
     * @example
     * // Get one Alunos
     * const alunos = await prisma.alunos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends alunosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, alunosFindFirstOrThrowArgs>
    ): Prisma__alunosClient<alunosGetPayload<T>>

    /**
     * Find zero or more Alunos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alunosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alunos
     * const alunos = await prisma.alunos.findMany()
     * 
     * // Get first 10 Alunos
     * const alunos = await prisma.alunos.findMany({ take: 10 })
     * 
     * // Only select the `id_aluno`
     * const alunosWithId_alunoOnly = await prisma.alunos.findMany({ select: { id_aluno: true } })
     * 
    **/
    findMany<T extends alunosFindManyArgs>(
      args?: SelectSubset<T, alunosFindManyArgs>
    ): Prisma.PrismaPromise<Array<alunosGetPayload<T>>>

    /**
     * Create a Alunos.
     * @param {alunosCreateArgs} args - Arguments to create a Alunos.
     * @example
     * // Create one Alunos
     * const Alunos = await prisma.alunos.create({
     *   data: {
     *     // ... data to create a Alunos
     *   }
     * })
     * 
    **/
    create<T extends alunosCreateArgs>(
      args: SelectSubset<T, alunosCreateArgs>
    ): Prisma__alunosClient<alunosGetPayload<T>>

    /**
     * Create many Alunos.
     *     @param {alunosCreateManyArgs} args - Arguments to create many Alunos.
     *     @example
     *     // Create many Alunos
     *     const alunos = await prisma.alunos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends alunosCreateManyArgs>(
      args?: SelectSubset<T, alunosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alunos.
     * @param {alunosDeleteArgs} args - Arguments to delete one Alunos.
     * @example
     * // Delete one Alunos
     * const Alunos = await prisma.alunos.delete({
     *   where: {
     *     // ... filter to delete one Alunos
     *   }
     * })
     * 
    **/
    delete<T extends alunosDeleteArgs>(
      args: SelectSubset<T, alunosDeleteArgs>
    ): Prisma__alunosClient<alunosGetPayload<T>>

    /**
     * Update one Alunos.
     * @param {alunosUpdateArgs} args - Arguments to update one Alunos.
     * @example
     * // Update one Alunos
     * const alunos = await prisma.alunos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends alunosUpdateArgs>(
      args: SelectSubset<T, alunosUpdateArgs>
    ): Prisma__alunosClient<alunosGetPayload<T>>

    /**
     * Delete zero or more Alunos.
     * @param {alunosDeleteManyArgs} args - Arguments to filter Alunos to delete.
     * @example
     * // Delete a few Alunos
     * const { count } = await prisma.alunos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends alunosDeleteManyArgs>(
      args?: SelectSubset<T, alunosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alunos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alunosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alunos
     * const alunos = await prisma.alunos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends alunosUpdateManyArgs>(
      args: SelectSubset<T, alunosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alunos.
     * @param {alunosUpsertArgs} args - Arguments to update or create a Alunos.
     * @example
     * // Update or create a Alunos
     * const alunos = await prisma.alunos.upsert({
     *   create: {
     *     // ... data to create a Alunos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alunos we want to update
     *   }
     * })
    **/
    upsert<T extends alunosUpsertArgs>(
      args: SelectSubset<T, alunosUpsertArgs>
    ): Prisma__alunosClient<alunosGetPayload<T>>

    /**
     * Count the number of Alunos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alunosCountArgs} args - Arguments to filter Alunos to count.
     * @example
     * // Count the number of Alunos
     * const count = await prisma.alunos.count({
     *   where: {
     *     // ... the filter for the Alunos we want to count
     *   }
     * })
    **/
    count<T extends alunosCountArgs>(
      args?: Subset<T, alunosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlunosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alunos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlunosAggregateArgs>(args: Subset<T, AlunosAggregateArgs>): Prisma.PrismaPromise<GetAlunosAggregateType<T>>

    /**
     * Group by Alunos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlunosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlunosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlunosGroupByArgs['orderBy'] }
        : { orderBy?: AlunosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlunosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlunosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for alunos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__alunosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    turma<T extends alunos$turmaArgs= {}>(args?: Subset<T, alunos$turmaArgs>): Prisma.PrismaPromise<Array<turmasGetPayload<T>>| Null>;

    pontos<T extends alunos$pontosArgs= {}>(args?: Subset<T, alunos$pontosArgs>): Prisma.PrismaPromise<Array<pontosGetPayload<T>>| Null>;

    atividades_concluidas<T extends alunos$atividades_concluidasArgs= {}>(args?: Subset<T, alunos$atividades_concluidasArgs>): Prisma.PrismaPromise<Array<atividades_concluidasGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * alunos base type for findUnique actions
   */
  export type alunosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the alunos
     */
    select?: alunosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alunosInclude | null
    /**
     * Filter, which alunos to fetch.
     */
    where: alunosWhereUniqueInput
  }

  /**
   * alunos findUnique
   */
  export interface alunosFindUniqueArgs extends alunosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * alunos findUniqueOrThrow
   */
  export type alunosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the alunos
     */
    select?: alunosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alunosInclude | null
    /**
     * Filter, which alunos to fetch.
     */
    where: alunosWhereUniqueInput
  }


  /**
   * alunos base type for findFirst actions
   */
  export type alunosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the alunos
     */
    select?: alunosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alunosInclude | null
    /**
     * Filter, which alunos to fetch.
     */
    where?: alunosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alunos to fetch.
     */
    orderBy?: Enumerable<alunosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alunos.
     */
    cursor?: alunosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alunos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alunos.
     */
    distinct?: Enumerable<AlunosScalarFieldEnum>
  }

  /**
   * alunos findFirst
   */
  export interface alunosFindFirstArgs extends alunosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * alunos findFirstOrThrow
   */
  export type alunosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the alunos
     */
    select?: alunosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alunosInclude | null
    /**
     * Filter, which alunos to fetch.
     */
    where?: alunosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alunos to fetch.
     */
    orderBy?: Enumerable<alunosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alunos.
     */
    cursor?: alunosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alunos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alunos.
     */
    distinct?: Enumerable<AlunosScalarFieldEnum>
  }


  /**
   * alunos findMany
   */
  export type alunosFindManyArgs = {
    /**
     * Select specific fields to fetch from the alunos
     */
    select?: alunosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alunosInclude | null
    /**
     * Filter, which alunos to fetch.
     */
    where?: alunosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alunos to fetch.
     */
    orderBy?: Enumerable<alunosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alunos.
     */
    cursor?: alunosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alunos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alunos.
     */
    skip?: number
    distinct?: Enumerable<AlunosScalarFieldEnum>
  }


  /**
   * alunos create
   */
  export type alunosCreateArgs = {
    /**
     * Select specific fields to fetch from the alunos
     */
    select?: alunosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alunosInclude | null
    /**
     * The data needed to create a alunos.
     */
    data: XOR<alunosCreateInput, alunosUncheckedCreateInput>
  }


  /**
   * alunos createMany
   */
  export type alunosCreateManyArgs = {
    /**
     * The data used to create many alunos.
     */
    data: Enumerable<alunosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * alunos update
   */
  export type alunosUpdateArgs = {
    /**
     * Select specific fields to fetch from the alunos
     */
    select?: alunosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alunosInclude | null
    /**
     * The data needed to update a alunos.
     */
    data: XOR<alunosUpdateInput, alunosUncheckedUpdateInput>
    /**
     * Choose, which alunos to update.
     */
    where: alunosWhereUniqueInput
  }


  /**
   * alunos updateMany
   */
  export type alunosUpdateManyArgs = {
    /**
     * The data used to update alunos.
     */
    data: XOR<alunosUpdateManyMutationInput, alunosUncheckedUpdateManyInput>
    /**
     * Filter which alunos to update
     */
    where?: alunosWhereInput
  }


  /**
   * alunos upsert
   */
  export type alunosUpsertArgs = {
    /**
     * Select specific fields to fetch from the alunos
     */
    select?: alunosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alunosInclude | null
    /**
     * The filter to search for the alunos to update in case it exists.
     */
    where: alunosWhereUniqueInput
    /**
     * In case the alunos found by the `where` argument doesn't exist, create a new alunos with this data.
     */
    create: XOR<alunosCreateInput, alunosUncheckedCreateInput>
    /**
     * In case the alunos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alunosUpdateInput, alunosUncheckedUpdateInput>
  }


  /**
   * alunos delete
   */
  export type alunosDeleteArgs = {
    /**
     * Select specific fields to fetch from the alunos
     */
    select?: alunosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alunosInclude | null
    /**
     * Filter which alunos to delete.
     */
    where: alunosWhereUniqueInput
  }


  /**
   * alunos deleteMany
   */
  export type alunosDeleteManyArgs = {
    /**
     * Filter which alunos to delete
     */
    where?: alunosWhereInput
  }


  /**
   * alunos.turma
   */
  export type alunos$turmaArgs = {
    /**
     * Select specific fields to fetch from the turmas
     */
    select?: turmasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: turmasInclude | null
    where?: turmasWhereInput
    orderBy?: Enumerable<turmasOrderByWithRelationInput>
    cursor?: turmasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TurmasScalarFieldEnum>
  }


  /**
   * alunos.pontos
   */
  export type alunos$pontosArgs = {
    /**
     * Select specific fields to fetch from the pontos
     */
    select?: pontosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pontosInclude | null
    where?: pontosWhereInput
    orderBy?: Enumerable<pontosOrderByWithRelationInput>
    cursor?: pontosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PontosScalarFieldEnum>
  }


  /**
   * alunos.atividades_concluidas
   */
  export type alunos$atividades_concluidasArgs = {
    /**
     * Select specific fields to fetch from the atividades_concluidas
     */
    select?: atividades_concluidasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividades_concluidasInclude | null
    where?: atividades_concluidasWhereInput
    orderBy?: Enumerable<atividades_concluidasOrderByWithRelationInput>
    cursor?: atividades_concluidasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Atividades_concluidasScalarFieldEnum>
  }


  /**
   * alunos without action
   */
  export type alunosArgs = {
    /**
     * Select specific fields to fetch from the alunos
     */
    select?: alunosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alunosInclude | null
  }



  /**
   * Model professores
   */


  export type AggregateProfessores = {
    _count: ProfessoresCountAggregateOutputType | null
    _avg: ProfessoresAvgAggregateOutputType | null
    _sum: ProfessoresSumAggregateOutputType | null
    _min: ProfessoresMinAggregateOutputType | null
    _max: ProfessoresMaxAggregateOutputType | null
  }

  export type ProfessoresAvgAggregateOutputType = {
    id_prof: number | null
  }

  export type ProfessoresSumAggregateOutputType = {
    id_prof: number | null
  }

  export type ProfessoresMinAggregateOutputType = {
    id_prof: number | null
    nome: string | null
    email: string | null
    senha: string | null
    nivel_de_acesso: string | null
  }

  export type ProfessoresMaxAggregateOutputType = {
    id_prof: number | null
    nome: string | null
    email: string | null
    senha: string | null
    nivel_de_acesso: string | null
  }

  export type ProfessoresCountAggregateOutputType = {
    id_prof: number
    nome: number
    email: number
    senha: number
    nivel_de_acesso: number
    _all: number
  }


  export type ProfessoresAvgAggregateInputType = {
    id_prof?: true
  }

  export type ProfessoresSumAggregateInputType = {
    id_prof?: true
  }

  export type ProfessoresMinAggregateInputType = {
    id_prof?: true
    nome?: true
    email?: true
    senha?: true
    nivel_de_acesso?: true
  }

  export type ProfessoresMaxAggregateInputType = {
    id_prof?: true
    nome?: true
    email?: true
    senha?: true
    nivel_de_acesso?: true
  }

  export type ProfessoresCountAggregateInputType = {
    id_prof?: true
    nome?: true
    email?: true
    senha?: true
    nivel_de_acesso?: true
    _all?: true
  }

  export type ProfessoresAggregateArgs = {
    /**
     * Filter which professores to aggregate.
     */
    where?: professoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of professores to fetch.
     */
    orderBy?: Enumerable<professoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: professoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` professores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` professores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned professores
    **/
    _count?: true | ProfessoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfessoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfessoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfessoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfessoresMaxAggregateInputType
  }

  export type GetProfessoresAggregateType<T extends ProfessoresAggregateArgs> = {
        [P in keyof T & keyof AggregateProfessores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfessores[P]>
      : GetScalarType<T[P], AggregateProfessores[P]>
  }




  export type ProfessoresGroupByArgs = {
    where?: professoresWhereInput
    orderBy?: Enumerable<professoresOrderByWithAggregationInput>
    by: ProfessoresScalarFieldEnum[]
    having?: professoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfessoresCountAggregateInputType | true
    _avg?: ProfessoresAvgAggregateInputType
    _sum?: ProfessoresSumAggregateInputType
    _min?: ProfessoresMinAggregateInputType
    _max?: ProfessoresMaxAggregateInputType
  }


  export type ProfessoresGroupByOutputType = {
    id_prof: number
    nome: string
    email: string
    senha: string
    nivel_de_acesso: string | null
    _count: ProfessoresCountAggregateOutputType | null
    _avg: ProfessoresAvgAggregateOutputType | null
    _sum: ProfessoresSumAggregateOutputType | null
    _min: ProfessoresMinAggregateOutputType | null
    _max: ProfessoresMaxAggregateOutputType | null
  }

  type GetProfessoresGroupByPayload<T extends ProfessoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProfessoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfessoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfessoresGroupByOutputType[P]>
            : GetScalarType<T[P], ProfessoresGroupByOutputType[P]>
        }
      >
    >


  export type professoresSelect = {
    id_prof?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    nivel_de_acesso?: boolean
    turma?: boolean | professores$turmaArgs
    _count?: boolean | ProfessoresCountOutputTypeArgs
  }


  export type professoresInclude = {
    turma?: boolean | professores$turmaArgs
    _count?: boolean | ProfessoresCountOutputTypeArgs
  }

  export type professoresGetPayload<S extends boolean | null | undefined | professoresArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? professores :
    S extends undefined ? never :
    S extends { include: any } & (professoresArgs | professoresFindManyArgs)
    ? professores  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'turma' ? Array < turmasGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProfessoresCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (professoresArgs | professoresFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'turma' ? Array < turmasGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProfessoresCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof professores ? professores[P] : never
  } 
      : professores


  type professoresCountArgs = 
    Omit<professoresFindManyArgs, 'select' | 'include'> & {
      select?: ProfessoresCountAggregateInputType | true
    }

  export interface professoresDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Professores that matches the filter.
     * @param {professoresFindUniqueArgs} args - Arguments to find a Professores
     * @example
     * // Get one Professores
     * const professores = await prisma.professores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends professoresFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, professoresFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'professores'> extends True ? Prisma__professoresClient<professoresGetPayload<T>> : Prisma__professoresClient<professoresGetPayload<T> | null, null>

    /**
     * Find one Professores that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {professoresFindUniqueOrThrowArgs} args - Arguments to find a Professores
     * @example
     * // Get one Professores
     * const professores = await prisma.professores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends professoresFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, professoresFindUniqueOrThrowArgs>
    ): Prisma__professoresClient<professoresGetPayload<T>>

    /**
     * Find the first Professores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professoresFindFirstArgs} args - Arguments to find a Professores
     * @example
     * // Get one Professores
     * const professores = await prisma.professores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends professoresFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, professoresFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'professores'> extends True ? Prisma__professoresClient<professoresGetPayload<T>> : Prisma__professoresClient<professoresGetPayload<T> | null, null>

    /**
     * Find the first Professores that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professoresFindFirstOrThrowArgs} args - Arguments to find a Professores
     * @example
     * // Get one Professores
     * const professores = await prisma.professores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends professoresFindFirstOrThrowArgs>(
      args?: SelectSubset<T, professoresFindFirstOrThrowArgs>
    ): Prisma__professoresClient<professoresGetPayload<T>>

    /**
     * Find zero or more Professores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professoresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Professores
     * const professores = await prisma.professores.findMany()
     * 
     * // Get first 10 Professores
     * const professores = await prisma.professores.findMany({ take: 10 })
     * 
     * // Only select the `id_prof`
     * const professoresWithId_profOnly = await prisma.professores.findMany({ select: { id_prof: true } })
     * 
    **/
    findMany<T extends professoresFindManyArgs>(
      args?: SelectSubset<T, professoresFindManyArgs>
    ): Prisma.PrismaPromise<Array<professoresGetPayload<T>>>

    /**
     * Create a Professores.
     * @param {professoresCreateArgs} args - Arguments to create a Professores.
     * @example
     * // Create one Professores
     * const Professores = await prisma.professores.create({
     *   data: {
     *     // ... data to create a Professores
     *   }
     * })
     * 
    **/
    create<T extends professoresCreateArgs>(
      args: SelectSubset<T, professoresCreateArgs>
    ): Prisma__professoresClient<professoresGetPayload<T>>

    /**
     * Create many Professores.
     *     @param {professoresCreateManyArgs} args - Arguments to create many Professores.
     *     @example
     *     // Create many Professores
     *     const professores = await prisma.professores.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends professoresCreateManyArgs>(
      args?: SelectSubset<T, professoresCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Professores.
     * @param {professoresDeleteArgs} args - Arguments to delete one Professores.
     * @example
     * // Delete one Professores
     * const Professores = await prisma.professores.delete({
     *   where: {
     *     // ... filter to delete one Professores
     *   }
     * })
     * 
    **/
    delete<T extends professoresDeleteArgs>(
      args: SelectSubset<T, professoresDeleteArgs>
    ): Prisma__professoresClient<professoresGetPayload<T>>

    /**
     * Update one Professores.
     * @param {professoresUpdateArgs} args - Arguments to update one Professores.
     * @example
     * // Update one Professores
     * const professores = await prisma.professores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends professoresUpdateArgs>(
      args: SelectSubset<T, professoresUpdateArgs>
    ): Prisma__professoresClient<professoresGetPayload<T>>

    /**
     * Delete zero or more Professores.
     * @param {professoresDeleteManyArgs} args - Arguments to filter Professores to delete.
     * @example
     * // Delete a few Professores
     * const { count } = await prisma.professores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends professoresDeleteManyArgs>(
      args?: SelectSubset<T, professoresDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Professores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Professores
     * const professores = await prisma.professores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends professoresUpdateManyArgs>(
      args: SelectSubset<T, professoresUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Professores.
     * @param {professoresUpsertArgs} args - Arguments to update or create a Professores.
     * @example
     * // Update or create a Professores
     * const professores = await prisma.professores.upsert({
     *   create: {
     *     // ... data to create a Professores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Professores we want to update
     *   }
     * })
    **/
    upsert<T extends professoresUpsertArgs>(
      args: SelectSubset<T, professoresUpsertArgs>
    ): Prisma__professoresClient<professoresGetPayload<T>>

    /**
     * Count the number of Professores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {professoresCountArgs} args - Arguments to filter Professores to count.
     * @example
     * // Count the number of Professores
     * const count = await prisma.professores.count({
     *   where: {
     *     // ... the filter for the Professores we want to count
     *   }
     * })
    **/
    count<T extends professoresCountArgs>(
      args?: Subset<T, professoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfessoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Professores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfessoresAggregateArgs>(args: Subset<T, ProfessoresAggregateArgs>): Prisma.PrismaPromise<GetProfessoresAggregateType<T>>

    /**
     * Group by Professores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfessoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfessoresGroupByArgs['orderBy'] }
        : { orderBy?: ProfessoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfessoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfessoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for professores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__professoresClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    turma<T extends professores$turmaArgs= {}>(args?: Subset<T, professores$turmaArgs>): Prisma.PrismaPromise<Array<turmasGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * professores base type for findUnique actions
   */
  export type professoresFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the professores
     */
    select?: professoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: professoresInclude | null
    /**
     * Filter, which professores to fetch.
     */
    where: professoresWhereUniqueInput
  }

  /**
   * professores findUnique
   */
  export interface professoresFindUniqueArgs extends professoresFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * professores findUniqueOrThrow
   */
  export type professoresFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the professores
     */
    select?: professoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: professoresInclude | null
    /**
     * Filter, which professores to fetch.
     */
    where: professoresWhereUniqueInput
  }


  /**
   * professores base type for findFirst actions
   */
  export type professoresFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the professores
     */
    select?: professoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: professoresInclude | null
    /**
     * Filter, which professores to fetch.
     */
    where?: professoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of professores to fetch.
     */
    orderBy?: Enumerable<professoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for professores.
     */
    cursor?: professoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` professores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` professores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of professores.
     */
    distinct?: Enumerable<ProfessoresScalarFieldEnum>
  }

  /**
   * professores findFirst
   */
  export interface professoresFindFirstArgs extends professoresFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * professores findFirstOrThrow
   */
  export type professoresFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the professores
     */
    select?: professoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: professoresInclude | null
    /**
     * Filter, which professores to fetch.
     */
    where?: professoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of professores to fetch.
     */
    orderBy?: Enumerable<professoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for professores.
     */
    cursor?: professoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` professores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` professores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of professores.
     */
    distinct?: Enumerable<ProfessoresScalarFieldEnum>
  }


  /**
   * professores findMany
   */
  export type professoresFindManyArgs = {
    /**
     * Select specific fields to fetch from the professores
     */
    select?: professoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: professoresInclude | null
    /**
     * Filter, which professores to fetch.
     */
    where?: professoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of professores to fetch.
     */
    orderBy?: Enumerable<professoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing professores.
     */
    cursor?: professoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` professores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` professores.
     */
    skip?: number
    distinct?: Enumerable<ProfessoresScalarFieldEnum>
  }


  /**
   * professores create
   */
  export type professoresCreateArgs = {
    /**
     * Select specific fields to fetch from the professores
     */
    select?: professoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: professoresInclude | null
    /**
     * The data needed to create a professores.
     */
    data: XOR<professoresCreateInput, professoresUncheckedCreateInput>
  }


  /**
   * professores createMany
   */
  export type professoresCreateManyArgs = {
    /**
     * The data used to create many professores.
     */
    data: Enumerable<professoresCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * professores update
   */
  export type professoresUpdateArgs = {
    /**
     * Select specific fields to fetch from the professores
     */
    select?: professoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: professoresInclude | null
    /**
     * The data needed to update a professores.
     */
    data: XOR<professoresUpdateInput, professoresUncheckedUpdateInput>
    /**
     * Choose, which professores to update.
     */
    where: professoresWhereUniqueInput
  }


  /**
   * professores updateMany
   */
  export type professoresUpdateManyArgs = {
    /**
     * The data used to update professores.
     */
    data: XOR<professoresUpdateManyMutationInput, professoresUncheckedUpdateManyInput>
    /**
     * Filter which professores to update
     */
    where?: professoresWhereInput
  }


  /**
   * professores upsert
   */
  export type professoresUpsertArgs = {
    /**
     * Select specific fields to fetch from the professores
     */
    select?: professoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: professoresInclude | null
    /**
     * The filter to search for the professores to update in case it exists.
     */
    where: professoresWhereUniqueInput
    /**
     * In case the professores found by the `where` argument doesn't exist, create a new professores with this data.
     */
    create: XOR<professoresCreateInput, professoresUncheckedCreateInput>
    /**
     * In case the professores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<professoresUpdateInput, professoresUncheckedUpdateInput>
  }


  /**
   * professores delete
   */
  export type professoresDeleteArgs = {
    /**
     * Select specific fields to fetch from the professores
     */
    select?: professoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: professoresInclude | null
    /**
     * Filter which professores to delete.
     */
    where: professoresWhereUniqueInput
  }


  /**
   * professores deleteMany
   */
  export type professoresDeleteManyArgs = {
    /**
     * Filter which professores to delete
     */
    where?: professoresWhereInput
  }


  /**
   * professores.turma
   */
  export type professores$turmaArgs = {
    /**
     * Select specific fields to fetch from the turmas
     */
    select?: turmasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: turmasInclude | null
    where?: turmasWhereInput
    orderBy?: Enumerable<turmasOrderByWithRelationInput>
    cursor?: turmasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TurmasScalarFieldEnum>
  }


  /**
   * professores without action
   */
  export type professoresArgs = {
    /**
     * Select specific fields to fetch from the professores
     */
    select?: professoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: professoresInclude | null
  }



  /**
   * Model atividades
   */


  export type AggregateAtividades = {
    _count: AtividadesCountAggregateOutputType | null
    _avg: AtividadesAvgAggregateOutputType | null
    _sum: AtividadesSumAggregateOutputType | null
    _min: AtividadesMinAggregateOutputType | null
    _max: AtividadesMaxAggregateOutputType | null
  }

  export type AtividadesAvgAggregateOutputType = {
    id_atividade: number | null
    id_turma: number | null
    pontos_conclusao: number | null
  }

  export type AtividadesSumAggregateOutputType = {
    id_atividade: number | null
    id_turma: number | null
    pontos_conclusao: number | null
  }

  export type AtividadesMinAggregateOutputType = {
    id_atividade: number | null
    id_turma: number | null
    titulo: string | null
    descricao: string | null
    prazo: Date | null
    pontos_conclusao: number | null
  }

  export type AtividadesMaxAggregateOutputType = {
    id_atividade: number | null
    id_turma: number | null
    titulo: string | null
    descricao: string | null
    prazo: Date | null
    pontos_conclusao: number | null
  }

  export type AtividadesCountAggregateOutputType = {
    id_atividade: number
    id_turma: number
    titulo: number
    descricao: number
    prazo: number
    pontos_conclusao: number
    _all: number
  }


  export type AtividadesAvgAggregateInputType = {
    id_atividade?: true
    id_turma?: true
    pontos_conclusao?: true
  }

  export type AtividadesSumAggregateInputType = {
    id_atividade?: true
    id_turma?: true
    pontos_conclusao?: true
  }

  export type AtividadesMinAggregateInputType = {
    id_atividade?: true
    id_turma?: true
    titulo?: true
    descricao?: true
    prazo?: true
    pontos_conclusao?: true
  }

  export type AtividadesMaxAggregateInputType = {
    id_atividade?: true
    id_turma?: true
    titulo?: true
    descricao?: true
    prazo?: true
    pontos_conclusao?: true
  }

  export type AtividadesCountAggregateInputType = {
    id_atividade?: true
    id_turma?: true
    titulo?: true
    descricao?: true
    prazo?: true
    pontos_conclusao?: true
    _all?: true
  }

  export type AtividadesAggregateArgs = {
    /**
     * Filter which atividades to aggregate.
     */
    where?: atividadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of atividades to fetch.
     */
    orderBy?: Enumerable<atividadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: atividadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` atividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` atividades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned atividades
    **/
    _count?: true | AtividadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AtividadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AtividadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AtividadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AtividadesMaxAggregateInputType
  }

  export type GetAtividadesAggregateType<T extends AtividadesAggregateArgs> = {
        [P in keyof T & keyof AggregateAtividades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtividades[P]>
      : GetScalarType<T[P], AggregateAtividades[P]>
  }




  export type AtividadesGroupByArgs = {
    where?: atividadesWhereInput
    orderBy?: Enumerable<atividadesOrderByWithAggregationInput>
    by: AtividadesScalarFieldEnum[]
    having?: atividadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AtividadesCountAggregateInputType | true
    _avg?: AtividadesAvgAggregateInputType
    _sum?: AtividadesSumAggregateInputType
    _min?: AtividadesMinAggregateInputType
    _max?: AtividadesMaxAggregateInputType
  }


  export type AtividadesGroupByOutputType = {
    id_atividade: number
    id_turma: number
    titulo: string
    descricao: string
    prazo: Date
    pontos_conclusao: number
    _count: AtividadesCountAggregateOutputType | null
    _avg: AtividadesAvgAggregateOutputType | null
    _sum: AtividadesSumAggregateOutputType | null
    _min: AtividadesMinAggregateOutputType | null
    _max: AtividadesMaxAggregateOutputType | null
  }

  type GetAtividadesGroupByPayload<T extends AtividadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AtividadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AtividadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AtividadesGroupByOutputType[P]>
            : GetScalarType<T[P], AtividadesGroupByOutputType[P]>
        }
      >
    >


  export type atividadesSelect = {
    id_atividade?: boolean
    id_turma?: boolean
    titulo?: boolean
    descricao?: boolean
    prazo?: boolean
    pontos_conclusao?: boolean
    turma?: boolean | turmasArgs
    atividades_concluidas?: boolean | atividades$atividades_concluidasArgs
    _count?: boolean | AtividadesCountOutputTypeArgs
  }


  export type atividadesInclude = {
    turma?: boolean | turmasArgs
    atividades_concluidas?: boolean | atividades$atividades_concluidasArgs
    _count?: boolean | AtividadesCountOutputTypeArgs
  }

  export type atividadesGetPayload<S extends boolean | null | undefined | atividadesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? atividades :
    S extends undefined ? never :
    S extends { include: any } & (atividadesArgs | atividadesFindManyArgs)
    ? atividades  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'turma' ? turmasGetPayload<S['include'][P]> :
        P extends 'atividades_concluidas' ? Array < atividades_concluidasGetPayload<S['include'][P]>>  :
        P extends '_count' ? AtividadesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (atividadesArgs | atividadesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'turma' ? turmasGetPayload<S['select'][P]> :
        P extends 'atividades_concluidas' ? Array < atividades_concluidasGetPayload<S['select'][P]>>  :
        P extends '_count' ? AtividadesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof atividades ? atividades[P] : never
  } 
      : atividades


  type atividadesCountArgs = 
    Omit<atividadesFindManyArgs, 'select' | 'include'> & {
      select?: AtividadesCountAggregateInputType | true
    }

  export interface atividadesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Atividades that matches the filter.
     * @param {atividadesFindUniqueArgs} args - Arguments to find a Atividades
     * @example
     * // Get one Atividades
     * const atividades = await prisma.atividades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends atividadesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, atividadesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'atividades'> extends True ? Prisma__atividadesClient<atividadesGetPayload<T>> : Prisma__atividadesClient<atividadesGetPayload<T> | null, null>

    /**
     * Find one Atividades that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {atividadesFindUniqueOrThrowArgs} args - Arguments to find a Atividades
     * @example
     * // Get one Atividades
     * const atividades = await prisma.atividades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends atividadesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, atividadesFindUniqueOrThrowArgs>
    ): Prisma__atividadesClient<atividadesGetPayload<T>>

    /**
     * Find the first Atividades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atividadesFindFirstArgs} args - Arguments to find a Atividades
     * @example
     * // Get one Atividades
     * const atividades = await prisma.atividades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends atividadesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, atividadesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'atividades'> extends True ? Prisma__atividadesClient<atividadesGetPayload<T>> : Prisma__atividadesClient<atividadesGetPayload<T> | null, null>

    /**
     * Find the first Atividades that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atividadesFindFirstOrThrowArgs} args - Arguments to find a Atividades
     * @example
     * // Get one Atividades
     * const atividades = await prisma.atividades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends atividadesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, atividadesFindFirstOrThrowArgs>
    ): Prisma__atividadesClient<atividadesGetPayload<T>>

    /**
     * Find zero or more Atividades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atividadesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Atividades
     * const atividades = await prisma.atividades.findMany()
     * 
     * // Get first 10 Atividades
     * const atividades = await prisma.atividades.findMany({ take: 10 })
     * 
     * // Only select the `id_atividade`
     * const atividadesWithId_atividadeOnly = await prisma.atividades.findMany({ select: { id_atividade: true } })
     * 
    **/
    findMany<T extends atividadesFindManyArgs>(
      args?: SelectSubset<T, atividadesFindManyArgs>
    ): Prisma.PrismaPromise<Array<atividadesGetPayload<T>>>

    /**
     * Create a Atividades.
     * @param {atividadesCreateArgs} args - Arguments to create a Atividades.
     * @example
     * // Create one Atividades
     * const Atividades = await prisma.atividades.create({
     *   data: {
     *     // ... data to create a Atividades
     *   }
     * })
     * 
    **/
    create<T extends atividadesCreateArgs>(
      args: SelectSubset<T, atividadesCreateArgs>
    ): Prisma__atividadesClient<atividadesGetPayload<T>>

    /**
     * Create many Atividades.
     *     @param {atividadesCreateManyArgs} args - Arguments to create many Atividades.
     *     @example
     *     // Create many Atividades
     *     const atividades = await prisma.atividades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends atividadesCreateManyArgs>(
      args?: SelectSubset<T, atividadesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Atividades.
     * @param {atividadesDeleteArgs} args - Arguments to delete one Atividades.
     * @example
     * // Delete one Atividades
     * const Atividades = await prisma.atividades.delete({
     *   where: {
     *     // ... filter to delete one Atividades
     *   }
     * })
     * 
    **/
    delete<T extends atividadesDeleteArgs>(
      args: SelectSubset<T, atividadesDeleteArgs>
    ): Prisma__atividadesClient<atividadesGetPayload<T>>

    /**
     * Update one Atividades.
     * @param {atividadesUpdateArgs} args - Arguments to update one Atividades.
     * @example
     * // Update one Atividades
     * const atividades = await prisma.atividades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends atividadesUpdateArgs>(
      args: SelectSubset<T, atividadesUpdateArgs>
    ): Prisma__atividadesClient<atividadesGetPayload<T>>

    /**
     * Delete zero or more Atividades.
     * @param {atividadesDeleteManyArgs} args - Arguments to filter Atividades to delete.
     * @example
     * // Delete a few Atividades
     * const { count } = await prisma.atividades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends atividadesDeleteManyArgs>(
      args?: SelectSubset<T, atividadesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Atividades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atividadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Atividades
     * const atividades = await prisma.atividades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends atividadesUpdateManyArgs>(
      args: SelectSubset<T, atividadesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Atividades.
     * @param {atividadesUpsertArgs} args - Arguments to update or create a Atividades.
     * @example
     * // Update or create a Atividades
     * const atividades = await prisma.atividades.upsert({
     *   create: {
     *     // ... data to create a Atividades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Atividades we want to update
     *   }
     * })
    **/
    upsert<T extends atividadesUpsertArgs>(
      args: SelectSubset<T, atividadesUpsertArgs>
    ): Prisma__atividadesClient<atividadesGetPayload<T>>

    /**
     * Count the number of Atividades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atividadesCountArgs} args - Arguments to filter Atividades to count.
     * @example
     * // Count the number of Atividades
     * const count = await prisma.atividades.count({
     *   where: {
     *     // ... the filter for the Atividades we want to count
     *   }
     * })
    **/
    count<T extends atividadesCountArgs>(
      args?: Subset<T, atividadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AtividadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Atividades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtividadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AtividadesAggregateArgs>(args: Subset<T, AtividadesAggregateArgs>): Prisma.PrismaPromise<GetAtividadesAggregateType<T>>

    /**
     * Group by Atividades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtividadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AtividadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AtividadesGroupByArgs['orderBy'] }
        : { orderBy?: AtividadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AtividadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtividadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for atividades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__atividadesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    turma<T extends turmasArgs= {}>(args?: Subset<T, turmasArgs>): Prisma__turmasClient<turmasGetPayload<T> | Null>;

    atividades_concluidas<T extends atividades$atividades_concluidasArgs= {}>(args?: Subset<T, atividades$atividades_concluidasArgs>): Prisma.PrismaPromise<Array<atividades_concluidasGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * atividades base type for findUnique actions
   */
  export type atividadesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the atividades
     */
    select?: atividadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividadesInclude | null
    /**
     * Filter, which atividades to fetch.
     */
    where: atividadesWhereUniqueInput
  }

  /**
   * atividades findUnique
   */
  export interface atividadesFindUniqueArgs extends atividadesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * atividades findUniqueOrThrow
   */
  export type atividadesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the atividades
     */
    select?: atividadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividadesInclude | null
    /**
     * Filter, which atividades to fetch.
     */
    where: atividadesWhereUniqueInput
  }


  /**
   * atividades base type for findFirst actions
   */
  export type atividadesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the atividades
     */
    select?: atividadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividadesInclude | null
    /**
     * Filter, which atividades to fetch.
     */
    where?: atividadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of atividades to fetch.
     */
    orderBy?: Enumerable<atividadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for atividades.
     */
    cursor?: atividadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` atividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` atividades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of atividades.
     */
    distinct?: Enumerable<AtividadesScalarFieldEnum>
  }

  /**
   * atividades findFirst
   */
  export interface atividadesFindFirstArgs extends atividadesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * atividades findFirstOrThrow
   */
  export type atividadesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the atividades
     */
    select?: atividadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividadesInclude | null
    /**
     * Filter, which atividades to fetch.
     */
    where?: atividadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of atividades to fetch.
     */
    orderBy?: Enumerable<atividadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for atividades.
     */
    cursor?: atividadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` atividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` atividades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of atividades.
     */
    distinct?: Enumerable<AtividadesScalarFieldEnum>
  }


  /**
   * atividades findMany
   */
  export type atividadesFindManyArgs = {
    /**
     * Select specific fields to fetch from the atividades
     */
    select?: atividadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividadesInclude | null
    /**
     * Filter, which atividades to fetch.
     */
    where?: atividadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of atividades to fetch.
     */
    orderBy?: Enumerable<atividadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing atividades.
     */
    cursor?: atividadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` atividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` atividades.
     */
    skip?: number
    distinct?: Enumerable<AtividadesScalarFieldEnum>
  }


  /**
   * atividades create
   */
  export type atividadesCreateArgs = {
    /**
     * Select specific fields to fetch from the atividades
     */
    select?: atividadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividadesInclude | null
    /**
     * The data needed to create a atividades.
     */
    data: XOR<atividadesCreateInput, atividadesUncheckedCreateInput>
  }


  /**
   * atividades createMany
   */
  export type atividadesCreateManyArgs = {
    /**
     * The data used to create many atividades.
     */
    data: Enumerable<atividadesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * atividades update
   */
  export type atividadesUpdateArgs = {
    /**
     * Select specific fields to fetch from the atividades
     */
    select?: atividadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividadesInclude | null
    /**
     * The data needed to update a atividades.
     */
    data: XOR<atividadesUpdateInput, atividadesUncheckedUpdateInput>
    /**
     * Choose, which atividades to update.
     */
    where: atividadesWhereUniqueInput
  }


  /**
   * atividades updateMany
   */
  export type atividadesUpdateManyArgs = {
    /**
     * The data used to update atividades.
     */
    data: XOR<atividadesUpdateManyMutationInput, atividadesUncheckedUpdateManyInput>
    /**
     * Filter which atividades to update
     */
    where?: atividadesWhereInput
  }


  /**
   * atividades upsert
   */
  export type atividadesUpsertArgs = {
    /**
     * Select specific fields to fetch from the atividades
     */
    select?: atividadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividadesInclude | null
    /**
     * The filter to search for the atividades to update in case it exists.
     */
    where: atividadesWhereUniqueInput
    /**
     * In case the atividades found by the `where` argument doesn't exist, create a new atividades with this data.
     */
    create: XOR<atividadesCreateInput, atividadesUncheckedCreateInput>
    /**
     * In case the atividades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<atividadesUpdateInput, atividadesUncheckedUpdateInput>
  }


  /**
   * atividades delete
   */
  export type atividadesDeleteArgs = {
    /**
     * Select specific fields to fetch from the atividades
     */
    select?: atividadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividadesInclude | null
    /**
     * Filter which atividades to delete.
     */
    where: atividadesWhereUniqueInput
  }


  /**
   * atividades deleteMany
   */
  export type atividadesDeleteManyArgs = {
    /**
     * Filter which atividades to delete
     */
    where?: atividadesWhereInput
  }


  /**
   * atividades.atividades_concluidas
   */
  export type atividades$atividades_concluidasArgs = {
    /**
     * Select specific fields to fetch from the atividades_concluidas
     */
    select?: atividades_concluidasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividades_concluidasInclude | null
    where?: atividades_concluidasWhereInput
    orderBy?: Enumerable<atividades_concluidasOrderByWithRelationInput>
    cursor?: atividades_concluidasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Atividades_concluidasScalarFieldEnum>
  }


  /**
   * atividades without action
   */
  export type atividadesArgs = {
    /**
     * Select specific fields to fetch from the atividades
     */
    select?: atividadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividadesInclude | null
  }



  /**
   * Model atividades_concluidas
   */


  export type AggregateAtividades_concluidas = {
    _count: Atividades_concluidasCountAggregateOutputType | null
    _avg: Atividades_concluidasAvgAggregateOutputType | null
    _sum: Atividades_concluidasSumAggregateOutputType | null
    _min: Atividades_concluidasMinAggregateOutputType | null
    _max: Atividades_concluidasMaxAggregateOutputType | null
  }

  export type Atividades_concluidasAvgAggregateOutputType = {
    id_concluida: number | null
    id_atividade: number | null
    id_aluno: number | null
  }

  export type Atividades_concluidasSumAggregateOutputType = {
    id_concluida: number | null
    id_atividade: number | null
    id_aluno: number | null
  }

  export type Atividades_concluidasMinAggregateOutputType = {
    id_concluida: number | null
    id_atividade: number | null
    id_aluno: number | null
    data_concluida: Date | null
    arquivo: string | null
  }

  export type Atividades_concluidasMaxAggregateOutputType = {
    id_concluida: number | null
    id_atividade: number | null
    id_aluno: number | null
    data_concluida: Date | null
    arquivo: string | null
  }

  export type Atividades_concluidasCountAggregateOutputType = {
    id_concluida: number
    id_atividade: number
    id_aluno: number
    data_concluida: number
    arquivo: number
    _all: number
  }


  export type Atividades_concluidasAvgAggregateInputType = {
    id_concluida?: true
    id_atividade?: true
    id_aluno?: true
  }

  export type Atividades_concluidasSumAggregateInputType = {
    id_concluida?: true
    id_atividade?: true
    id_aluno?: true
  }

  export type Atividades_concluidasMinAggregateInputType = {
    id_concluida?: true
    id_atividade?: true
    id_aluno?: true
    data_concluida?: true
    arquivo?: true
  }

  export type Atividades_concluidasMaxAggregateInputType = {
    id_concluida?: true
    id_atividade?: true
    id_aluno?: true
    data_concluida?: true
    arquivo?: true
  }

  export type Atividades_concluidasCountAggregateInputType = {
    id_concluida?: true
    id_atividade?: true
    id_aluno?: true
    data_concluida?: true
    arquivo?: true
    _all?: true
  }

  export type Atividades_concluidasAggregateArgs = {
    /**
     * Filter which atividades_concluidas to aggregate.
     */
    where?: atividades_concluidasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of atividades_concluidas to fetch.
     */
    orderBy?: Enumerable<atividades_concluidasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: atividades_concluidasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` atividades_concluidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` atividades_concluidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned atividades_concluidas
    **/
    _count?: true | Atividades_concluidasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Atividades_concluidasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Atividades_concluidasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Atividades_concluidasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Atividades_concluidasMaxAggregateInputType
  }

  export type GetAtividades_concluidasAggregateType<T extends Atividades_concluidasAggregateArgs> = {
        [P in keyof T & keyof AggregateAtividades_concluidas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtividades_concluidas[P]>
      : GetScalarType<T[P], AggregateAtividades_concluidas[P]>
  }




  export type Atividades_concluidasGroupByArgs = {
    where?: atividades_concluidasWhereInput
    orderBy?: Enumerable<atividades_concluidasOrderByWithAggregationInput>
    by: Atividades_concluidasScalarFieldEnum[]
    having?: atividades_concluidasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Atividades_concluidasCountAggregateInputType | true
    _avg?: Atividades_concluidasAvgAggregateInputType
    _sum?: Atividades_concluidasSumAggregateInputType
    _min?: Atividades_concluidasMinAggregateInputType
    _max?: Atividades_concluidasMaxAggregateInputType
  }


  export type Atividades_concluidasGroupByOutputType = {
    id_concluida: number
    id_atividade: number
    id_aluno: number
    data_concluida: Date
    arquivo: string
    _count: Atividades_concluidasCountAggregateOutputType | null
    _avg: Atividades_concluidasAvgAggregateOutputType | null
    _sum: Atividades_concluidasSumAggregateOutputType | null
    _min: Atividades_concluidasMinAggregateOutputType | null
    _max: Atividades_concluidasMaxAggregateOutputType | null
  }

  type GetAtividades_concluidasGroupByPayload<T extends Atividades_concluidasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Atividades_concluidasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Atividades_concluidasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Atividades_concluidasGroupByOutputType[P]>
            : GetScalarType<T[P], Atividades_concluidasGroupByOutputType[P]>
        }
      >
    >


  export type atividades_concluidasSelect = {
    id_concluida?: boolean
    id_atividade?: boolean
    id_aluno?: boolean
    data_concluida?: boolean
    arquivo?: boolean
    atividade?: boolean | atividadesArgs
    aluno?: boolean | alunosArgs
  }


  export type atividades_concluidasInclude = {
    atividade?: boolean | atividadesArgs
    aluno?: boolean | alunosArgs
  }

  export type atividades_concluidasGetPayload<S extends boolean | null | undefined | atividades_concluidasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? atividades_concluidas :
    S extends undefined ? never :
    S extends { include: any } & (atividades_concluidasArgs | atividades_concluidasFindManyArgs)
    ? atividades_concluidas  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'atividade' ? atividadesGetPayload<S['include'][P]> :
        P extends 'aluno' ? alunosGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (atividades_concluidasArgs | atividades_concluidasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'atividade' ? atividadesGetPayload<S['select'][P]> :
        P extends 'aluno' ? alunosGetPayload<S['select'][P]> :  P extends keyof atividades_concluidas ? atividades_concluidas[P] : never
  } 
      : atividades_concluidas


  type atividades_concluidasCountArgs = 
    Omit<atividades_concluidasFindManyArgs, 'select' | 'include'> & {
      select?: Atividades_concluidasCountAggregateInputType | true
    }

  export interface atividades_concluidasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Atividades_concluidas that matches the filter.
     * @param {atividades_concluidasFindUniqueArgs} args - Arguments to find a Atividades_concluidas
     * @example
     * // Get one Atividades_concluidas
     * const atividades_concluidas = await prisma.atividades_concluidas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends atividades_concluidasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, atividades_concluidasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'atividades_concluidas'> extends True ? Prisma__atividades_concluidasClient<atividades_concluidasGetPayload<T>> : Prisma__atividades_concluidasClient<atividades_concluidasGetPayload<T> | null, null>

    /**
     * Find one Atividades_concluidas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {atividades_concluidasFindUniqueOrThrowArgs} args - Arguments to find a Atividades_concluidas
     * @example
     * // Get one Atividades_concluidas
     * const atividades_concluidas = await prisma.atividades_concluidas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends atividades_concluidasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, atividades_concluidasFindUniqueOrThrowArgs>
    ): Prisma__atividades_concluidasClient<atividades_concluidasGetPayload<T>>

    /**
     * Find the first Atividades_concluidas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atividades_concluidasFindFirstArgs} args - Arguments to find a Atividades_concluidas
     * @example
     * // Get one Atividades_concluidas
     * const atividades_concluidas = await prisma.atividades_concluidas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends atividades_concluidasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, atividades_concluidasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'atividades_concluidas'> extends True ? Prisma__atividades_concluidasClient<atividades_concluidasGetPayload<T>> : Prisma__atividades_concluidasClient<atividades_concluidasGetPayload<T> | null, null>

    /**
     * Find the first Atividades_concluidas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atividades_concluidasFindFirstOrThrowArgs} args - Arguments to find a Atividades_concluidas
     * @example
     * // Get one Atividades_concluidas
     * const atividades_concluidas = await prisma.atividades_concluidas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends atividades_concluidasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, atividades_concluidasFindFirstOrThrowArgs>
    ): Prisma__atividades_concluidasClient<atividades_concluidasGetPayload<T>>

    /**
     * Find zero or more Atividades_concluidas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atividades_concluidasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Atividades_concluidas
     * const atividades_concluidas = await prisma.atividades_concluidas.findMany()
     * 
     * // Get first 10 Atividades_concluidas
     * const atividades_concluidas = await prisma.atividades_concluidas.findMany({ take: 10 })
     * 
     * // Only select the `id_concluida`
     * const atividades_concluidasWithId_concluidaOnly = await prisma.atividades_concluidas.findMany({ select: { id_concluida: true } })
     * 
    **/
    findMany<T extends atividades_concluidasFindManyArgs>(
      args?: SelectSubset<T, atividades_concluidasFindManyArgs>
    ): Prisma.PrismaPromise<Array<atividades_concluidasGetPayload<T>>>

    /**
     * Create a Atividades_concluidas.
     * @param {atividades_concluidasCreateArgs} args - Arguments to create a Atividades_concluidas.
     * @example
     * // Create one Atividades_concluidas
     * const Atividades_concluidas = await prisma.atividades_concluidas.create({
     *   data: {
     *     // ... data to create a Atividades_concluidas
     *   }
     * })
     * 
    **/
    create<T extends atividades_concluidasCreateArgs>(
      args: SelectSubset<T, atividades_concluidasCreateArgs>
    ): Prisma__atividades_concluidasClient<atividades_concluidasGetPayload<T>>

    /**
     * Create many Atividades_concluidas.
     *     @param {atividades_concluidasCreateManyArgs} args - Arguments to create many Atividades_concluidas.
     *     @example
     *     // Create many Atividades_concluidas
     *     const atividades_concluidas = await prisma.atividades_concluidas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends atividades_concluidasCreateManyArgs>(
      args?: SelectSubset<T, atividades_concluidasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Atividades_concluidas.
     * @param {atividades_concluidasDeleteArgs} args - Arguments to delete one Atividades_concluidas.
     * @example
     * // Delete one Atividades_concluidas
     * const Atividades_concluidas = await prisma.atividades_concluidas.delete({
     *   where: {
     *     // ... filter to delete one Atividades_concluidas
     *   }
     * })
     * 
    **/
    delete<T extends atividades_concluidasDeleteArgs>(
      args: SelectSubset<T, atividades_concluidasDeleteArgs>
    ): Prisma__atividades_concluidasClient<atividades_concluidasGetPayload<T>>

    /**
     * Update one Atividades_concluidas.
     * @param {atividades_concluidasUpdateArgs} args - Arguments to update one Atividades_concluidas.
     * @example
     * // Update one Atividades_concluidas
     * const atividades_concluidas = await prisma.atividades_concluidas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends atividades_concluidasUpdateArgs>(
      args: SelectSubset<T, atividades_concluidasUpdateArgs>
    ): Prisma__atividades_concluidasClient<atividades_concluidasGetPayload<T>>

    /**
     * Delete zero or more Atividades_concluidas.
     * @param {atividades_concluidasDeleteManyArgs} args - Arguments to filter Atividades_concluidas to delete.
     * @example
     * // Delete a few Atividades_concluidas
     * const { count } = await prisma.atividades_concluidas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends atividades_concluidasDeleteManyArgs>(
      args?: SelectSubset<T, atividades_concluidasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Atividades_concluidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atividades_concluidasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Atividades_concluidas
     * const atividades_concluidas = await prisma.atividades_concluidas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends atividades_concluidasUpdateManyArgs>(
      args: SelectSubset<T, atividades_concluidasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Atividades_concluidas.
     * @param {atividades_concluidasUpsertArgs} args - Arguments to update or create a Atividades_concluidas.
     * @example
     * // Update or create a Atividades_concluidas
     * const atividades_concluidas = await prisma.atividades_concluidas.upsert({
     *   create: {
     *     // ... data to create a Atividades_concluidas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Atividades_concluidas we want to update
     *   }
     * })
    **/
    upsert<T extends atividades_concluidasUpsertArgs>(
      args: SelectSubset<T, atividades_concluidasUpsertArgs>
    ): Prisma__atividades_concluidasClient<atividades_concluidasGetPayload<T>>

    /**
     * Count the number of Atividades_concluidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atividades_concluidasCountArgs} args - Arguments to filter Atividades_concluidas to count.
     * @example
     * // Count the number of Atividades_concluidas
     * const count = await prisma.atividades_concluidas.count({
     *   where: {
     *     // ... the filter for the Atividades_concluidas we want to count
     *   }
     * })
    **/
    count<T extends atividades_concluidasCountArgs>(
      args?: Subset<T, atividades_concluidasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Atividades_concluidasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Atividades_concluidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Atividades_concluidasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Atividades_concluidasAggregateArgs>(args: Subset<T, Atividades_concluidasAggregateArgs>): Prisma.PrismaPromise<GetAtividades_concluidasAggregateType<T>>

    /**
     * Group by Atividades_concluidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Atividades_concluidasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Atividades_concluidasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Atividades_concluidasGroupByArgs['orderBy'] }
        : { orderBy?: Atividades_concluidasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Atividades_concluidasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtividades_concluidasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for atividades_concluidas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__atividades_concluidasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    atividade<T extends atividadesArgs= {}>(args?: Subset<T, atividadesArgs>): Prisma__atividadesClient<atividadesGetPayload<T> | Null>;

    aluno<T extends alunosArgs= {}>(args?: Subset<T, alunosArgs>): Prisma__alunosClient<alunosGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * atividades_concluidas base type for findUnique actions
   */
  export type atividades_concluidasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the atividades_concluidas
     */
    select?: atividades_concluidasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividades_concluidasInclude | null
    /**
     * Filter, which atividades_concluidas to fetch.
     */
    where: atividades_concluidasWhereUniqueInput
  }

  /**
   * atividades_concluidas findUnique
   */
  export interface atividades_concluidasFindUniqueArgs extends atividades_concluidasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * atividades_concluidas findUniqueOrThrow
   */
  export type atividades_concluidasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the atividades_concluidas
     */
    select?: atividades_concluidasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividades_concluidasInclude | null
    /**
     * Filter, which atividades_concluidas to fetch.
     */
    where: atividades_concluidasWhereUniqueInput
  }


  /**
   * atividades_concluidas base type for findFirst actions
   */
  export type atividades_concluidasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the atividades_concluidas
     */
    select?: atividades_concluidasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividades_concluidasInclude | null
    /**
     * Filter, which atividades_concluidas to fetch.
     */
    where?: atividades_concluidasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of atividades_concluidas to fetch.
     */
    orderBy?: Enumerable<atividades_concluidasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for atividades_concluidas.
     */
    cursor?: atividades_concluidasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` atividades_concluidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` atividades_concluidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of atividades_concluidas.
     */
    distinct?: Enumerable<Atividades_concluidasScalarFieldEnum>
  }

  /**
   * atividades_concluidas findFirst
   */
  export interface atividades_concluidasFindFirstArgs extends atividades_concluidasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * atividades_concluidas findFirstOrThrow
   */
  export type atividades_concluidasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the atividades_concluidas
     */
    select?: atividades_concluidasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividades_concluidasInclude | null
    /**
     * Filter, which atividades_concluidas to fetch.
     */
    where?: atividades_concluidasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of atividades_concluidas to fetch.
     */
    orderBy?: Enumerable<atividades_concluidasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for atividades_concluidas.
     */
    cursor?: atividades_concluidasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` atividades_concluidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` atividades_concluidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of atividades_concluidas.
     */
    distinct?: Enumerable<Atividades_concluidasScalarFieldEnum>
  }


  /**
   * atividades_concluidas findMany
   */
  export type atividades_concluidasFindManyArgs = {
    /**
     * Select specific fields to fetch from the atividades_concluidas
     */
    select?: atividades_concluidasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividades_concluidasInclude | null
    /**
     * Filter, which atividades_concluidas to fetch.
     */
    where?: atividades_concluidasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of atividades_concluidas to fetch.
     */
    orderBy?: Enumerable<atividades_concluidasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing atividades_concluidas.
     */
    cursor?: atividades_concluidasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` atividades_concluidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` atividades_concluidas.
     */
    skip?: number
    distinct?: Enumerable<Atividades_concluidasScalarFieldEnum>
  }


  /**
   * atividades_concluidas create
   */
  export type atividades_concluidasCreateArgs = {
    /**
     * Select specific fields to fetch from the atividades_concluidas
     */
    select?: atividades_concluidasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividades_concluidasInclude | null
    /**
     * The data needed to create a atividades_concluidas.
     */
    data: XOR<atividades_concluidasCreateInput, atividades_concluidasUncheckedCreateInput>
  }


  /**
   * atividades_concluidas createMany
   */
  export type atividades_concluidasCreateManyArgs = {
    /**
     * The data used to create many atividades_concluidas.
     */
    data: Enumerable<atividades_concluidasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * atividades_concluidas update
   */
  export type atividades_concluidasUpdateArgs = {
    /**
     * Select specific fields to fetch from the atividades_concluidas
     */
    select?: atividades_concluidasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividades_concluidasInclude | null
    /**
     * The data needed to update a atividades_concluidas.
     */
    data: XOR<atividades_concluidasUpdateInput, atividades_concluidasUncheckedUpdateInput>
    /**
     * Choose, which atividades_concluidas to update.
     */
    where: atividades_concluidasWhereUniqueInput
  }


  /**
   * atividades_concluidas updateMany
   */
  export type atividades_concluidasUpdateManyArgs = {
    /**
     * The data used to update atividades_concluidas.
     */
    data: XOR<atividades_concluidasUpdateManyMutationInput, atividades_concluidasUncheckedUpdateManyInput>
    /**
     * Filter which atividades_concluidas to update
     */
    where?: atividades_concluidasWhereInput
  }


  /**
   * atividades_concluidas upsert
   */
  export type atividades_concluidasUpsertArgs = {
    /**
     * Select specific fields to fetch from the atividades_concluidas
     */
    select?: atividades_concluidasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividades_concluidasInclude | null
    /**
     * The filter to search for the atividades_concluidas to update in case it exists.
     */
    where: atividades_concluidasWhereUniqueInput
    /**
     * In case the atividades_concluidas found by the `where` argument doesn't exist, create a new atividades_concluidas with this data.
     */
    create: XOR<atividades_concluidasCreateInput, atividades_concluidasUncheckedCreateInput>
    /**
     * In case the atividades_concluidas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<atividades_concluidasUpdateInput, atividades_concluidasUncheckedUpdateInput>
  }


  /**
   * atividades_concluidas delete
   */
  export type atividades_concluidasDeleteArgs = {
    /**
     * Select specific fields to fetch from the atividades_concluidas
     */
    select?: atividades_concluidasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividades_concluidasInclude | null
    /**
     * Filter which atividades_concluidas to delete.
     */
    where: atividades_concluidasWhereUniqueInput
  }


  /**
   * atividades_concluidas deleteMany
   */
  export type atividades_concluidasDeleteManyArgs = {
    /**
     * Filter which atividades_concluidas to delete
     */
    where?: atividades_concluidasWhereInput
  }


  /**
   * atividades_concluidas without action
   */
  export type atividades_concluidasArgs = {
    /**
     * Select specific fields to fetch from the atividades_concluidas
     */
    select?: atividades_concluidasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividades_concluidasInclude | null
  }



  /**
   * Model turmas
   */


  export type AggregateTurmas = {
    _count: TurmasCountAggregateOutputType | null
    _avg: TurmasAvgAggregateOutputType | null
    _sum: TurmasSumAggregateOutputType | null
    _min: TurmasMinAggregateOutputType | null
    _max: TurmasMaxAggregateOutputType | null
  }

  export type TurmasAvgAggregateOutputType = {
    id_turma: number | null
  }

  export type TurmasSumAggregateOutputType = {
    id_turma: number | null
  }

  export type TurmasMinAggregateOutputType = {
    id_turma: number | null
    nome: string | null
    codigo: string | null
  }

  export type TurmasMaxAggregateOutputType = {
    id_turma: number | null
    nome: string | null
    codigo: string | null
  }

  export type TurmasCountAggregateOutputType = {
    id_turma: number
    nome: number
    codigo: number
    _all: number
  }


  export type TurmasAvgAggregateInputType = {
    id_turma?: true
  }

  export type TurmasSumAggregateInputType = {
    id_turma?: true
  }

  export type TurmasMinAggregateInputType = {
    id_turma?: true
    nome?: true
    codigo?: true
  }

  export type TurmasMaxAggregateInputType = {
    id_turma?: true
    nome?: true
    codigo?: true
  }

  export type TurmasCountAggregateInputType = {
    id_turma?: true
    nome?: true
    codigo?: true
    _all?: true
  }

  export type TurmasAggregateArgs = {
    /**
     * Filter which turmas to aggregate.
     */
    where?: turmasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of turmas to fetch.
     */
    orderBy?: Enumerable<turmasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: turmasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` turmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned turmas
    **/
    _count?: true | TurmasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TurmasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TurmasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TurmasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TurmasMaxAggregateInputType
  }

  export type GetTurmasAggregateType<T extends TurmasAggregateArgs> = {
        [P in keyof T & keyof AggregateTurmas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTurmas[P]>
      : GetScalarType<T[P], AggregateTurmas[P]>
  }




  export type TurmasGroupByArgs = {
    where?: turmasWhereInput
    orderBy?: Enumerable<turmasOrderByWithAggregationInput>
    by: TurmasScalarFieldEnum[]
    having?: turmasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TurmasCountAggregateInputType | true
    _avg?: TurmasAvgAggregateInputType
    _sum?: TurmasSumAggregateInputType
    _min?: TurmasMinAggregateInputType
    _max?: TurmasMaxAggregateInputType
  }


  export type TurmasGroupByOutputType = {
    id_turma: number
    nome: string
    codigo: string
    _count: TurmasCountAggregateOutputType | null
    _avg: TurmasAvgAggregateOutputType | null
    _sum: TurmasSumAggregateOutputType | null
    _min: TurmasMinAggregateOutputType | null
    _max: TurmasMaxAggregateOutputType | null
  }

  type GetTurmasGroupByPayload<T extends TurmasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TurmasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TurmasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TurmasGroupByOutputType[P]>
            : GetScalarType<T[P], TurmasGroupByOutputType[P]>
        }
      >
    >


  export type turmasSelect = {
    id_turma?: boolean
    nome?: boolean
    codigo?: boolean
    professores?: boolean | turmas$professoresArgs
    alunos?: boolean | turmas$alunosArgs
    atividades?: boolean | turmas$atividadesArgs
    pontos?: boolean | turmas$pontosArgs
    premios?: boolean | turmas$premiosArgs
    _count?: boolean | TurmasCountOutputTypeArgs
  }


  export type turmasInclude = {
    professores?: boolean | turmas$professoresArgs
    alunos?: boolean | turmas$alunosArgs
    atividades?: boolean | turmas$atividadesArgs
    pontos?: boolean | turmas$pontosArgs
    premios?: boolean | turmas$premiosArgs
    _count?: boolean | TurmasCountOutputTypeArgs
  }

  export type turmasGetPayload<S extends boolean | null | undefined | turmasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? turmas :
    S extends undefined ? never :
    S extends { include: any } & (turmasArgs | turmasFindManyArgs)
    ? turmas  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'professores' ? Array < professoresGetPayload<S['include'][P]>>  :
        P extends 'alunos' ? Array < alunosGetPayload<S['include'][P]>>  :
        P extends 'atividades' ? Array < atividadesGetPayload<S['include'][P]>>  :
        P extends 'pontos' ? Array < pontosGetPayload<S['include'][P]>>  :
        P extends 'premios' ? Array < premiosGetPayload<S['include'][P]>>  :
        P extends '_count' ? TurmasCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (turmasArgs | turmasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'professores' ? Array < professoresGetPayload<S['select'][P]>>  :
        P extends 'alunos' ? Array < alunosGetPayload<S['select'][P]>>  :
        P extends 'atividades' ? Array < atividadesGetPayload<S['select'][P]>>  :
        P extends 'pontos' ? Array < pontosGetPayload<S['select'][P]>>  :
        P extends 'premios' ? Array < premiosGetPayload<S['select'][P]>>  :
        P extends '_count' ? TurmasCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof turmas ? turmas[P] : never
  } 
      : turmas


  type turmasCountArgs = 
    Omit<turmasFindManyArgs, 'select' | 'include'> & {
      select?: TurmasCountAggregateInputType | true
    }

  export interface turmasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Turmas that matches the filter.
     * @param {turmasFindUniqueArgs} args - Arguments to find a Turmas
     * @example
     * // Get one Turmas
     * const turmas = await prisma.turmas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends turmasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, turmasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'turmas'> extends True ? Prisma__turmasClient<turmasGetPayload<T>> : Prisma__turmasClient<turmasGetPayload<T> | null, null>

    /**
     * Find one Turmas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {turmasFindUniqueOrThrowArgs} args - Arguments to find a Turmas
     * @example
     * // Get one Turmas
     * const turmas = await prisma.turmas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends turmasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, turmasFindUniqueOrThrowArgs>
    ): Prisma__turmasClient<turmasGetPayload<T>>

    /**
     * Find the first Turmas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turmasFindFirstArgs} args - Arguments to find a Turmas
     * @example
     * // Get one Turmas
     * const turmas = await prisma.turmas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends turmasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, turmasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'turmas'> extends True ? Prisma__turmasClient<turmasGetPayload<T>> : Prisma__turmasClient<turmasGetPayload<T> | null, null>

    /**
     * Find the first Turmas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turmasFindFirstOrThrowArgs} args - Arguments to find a Turmas
     * @example
     * // Get one Turmas
     * const turmas = await prisma.turmas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends turmasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, turmasFindFirstOrThrowArgs>
    ): Prisma__turmasClient<turmasGetPayload<T>>

    /**
     * Find zero or more Turmas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turmasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Turmas
     * const turmas = await prisma.turmas.findMany()
     * 
     * // Get first 10 Turmas
     * const turmas = await prisma.turmas.findMany({ take: 10 })
     * 
     * // Only select the `id_turma`
     * const turmasWithId_turmaOnly = await prisma.turmas.findMany({ select: { id_turma: true } })
     * 
    **/
    findMany<T extends turmasFindManyArgs>(
      args?: SelectSubset<T, turmasFindManyArgs>
    ): Prisma.PrismaPromise<Array<turmasGetPayload<T>>>

    /**
     * Create a Turmas.
     * @param {turmasCreateArgs} args - Arguments to create a Turmas.
     * @example
     * // Create one Turmas
     * const Turmas = await prisma.turmas.create({
     *   data: {
     *     // ... data to create a Turmas
     *   }
     * })
     * 
    **/
    create<T extends turmasCreateArgs>(
      args: SelectSubset<T, turmasCreateArgs>
    ): Prisma__turmasClient<turmasGetPayload<T>>

    /**
     * Create many Turmas.
     *     @param {turmasCreateManyArgs} args - Arguments to create many Turmas.
     *     @example
     *     // Create many Turmas
     *     const turmas = await prisma.turmas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends turmasCreateManyArgs>(
      args?: SelectSubset<T, turmasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Turmas.
     * @param {turmasDeleteArgs} args - Arguments to delete one Turmas.
     * @example
     * // Delete one Turmas
     * const Turmas = await prisma.turmas.delete({
     *   where: {
     *     // ... filter to delete one Turmas
     *   }
     * })
     * 
    **/
    delete<T extends turmasDeleteArgs>(
      args: SelectSubset<T, turmasDeleteArgs>
    ): Prisma__turmasClient<turmasGetPayload<T>>

    /**
     * Update one Turmas.
     * @param {turmasUpdateArgs} args - Arguments to update one Turmas.
     * @example
     * // Update one Turmas
     * const turmas = await prisma.turmas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends turmasUpdateArgs>(
      args: SelectSubset<T, turmasUpdateArgs>
    ): Prisma__turmasClient<turmasGetPayload<T>>

    /**
     * Delete zero or more Turmas.
     * @param {turmasDeleteManyArgs} args - Arguments to filter Turmas to delete.
     * @example
     * // Delete a few Turmas
     * const { count } = await prisma.turmas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends turmasDeleteManyArgs>(
      args?: SelectSubset<T, turmasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Turmas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turmasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Turmas
     * const turmas = await prisma.turmas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends turmasUpdateManyArgs>(
      args: SelectSubset<T, turmasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Turmas.
     * @param {turmasUpsertArgs} args - Arguments to update or create a Turmas.
     * @example
     * // Update or create a Turmas
     * const turmas = await prisma.turmas.upsert({
     *   create: {
     *     // ... data to create a Turmas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Turmas we want to update
     *   }
     * })
    **/
    upsert<T extends turmasUpsertArgs>(
      args: SelectSubset<T, turmasUpsertArgs>
    ): Prisma__turmasClient<turmasGetPayload<T>>

    /**
     * Count the number of Turmas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turmasCountArgs} args - Arguments to filter Turmas to count.
     * @example
     * // Count the number of Turmas
     * const count = await prisma.turmas.count({
     *   where: {
     *     // ... the filter for the Turmas we want to count
     *   }
     * })
    **/
    count<T extends turmasCountArgs>(
      args?: Subset<T, turmasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TurmasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Turmas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TurmasAggregateArgs>(args: Subset<T, TurmasAggregateArgs>): Prisma.PrismaPromise<GetTurmasAggregateType<T>>

    /**
     * Group by Turmas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TurmasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TurmasGroupByArgs['orderBy'] }
        : { orderBy?: TurmasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TurmasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTurmasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for turmas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__turmasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    professores<T extends turmas$professoresArgs= {}>(args?: Subset<T, turmas$professoresArgs>): Prisma.PrismaPromise<Array<professoresGetPayload<T>>| Null>;

    alunos<T extends turmas$alunosArgs= {}>(args?: Subset<T, turmas$alunosArgs>): Prisma.PrismaPromise<Array<alunosGetPayload<T>>| Null>;

    atividades<T extends turmas$atividadesArgs= {}>(args?: Subset<T, turmas$atividadesArgs>): Prisma.PrismaPromise<Array<atividadesGetPayload<T>>| Null>;

    pontos<T extends turmas$pontosArgs= {}>(args?: Subset<T, turmas$pontosArgs>): Prisma.PrismaPromise<Array<pontosGetPayload<T>>| Null>;

    premios<T extends turmas$premiosArgs= {}>(args?: Subset<T, turmas$premiosArgs>): Prisma.PrismaPromise<Array<premiosGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * turmas base type for findUnique actions
   */
  export type turmasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the turmas
     */
    select?: turmasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: turmasInclude | null
    /**
     * Filter, which turmas to fetch.
     */
    where: turmasWhereUniqueInput
  }

  /**
   * turmas findUnique
   */
  export interface turmasFindUniqueArgs extends turmasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * turmas findUniqueOrThrow
   */
  export type turmasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the turmas
     */
    select?: turmasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: turmasInclude | null
    /**
     * Filter, which turmas to fetch.
     */
    where: turmasWhereUniqueInput
  }


  /**
   * turmas base type for findFirst actions
   */
  export type turmasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the turmas
     */
    select?: turmasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: turmasInclude | null
    /**
     * Filter, which turmas to fetch.
     */
    where?: turmasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of turmas to fetch.
     */
    orderBy?: Enumerable<turmasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for turmas.
     */
    cursor?: turmasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` turmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of turmas.
     */
    distinct?: Enumerable<TurmasScalarFieldEnum>
  }

  /**
   * turmas findFirst
   */
  export interface turmasFindFirstArgs extends turmasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * turmas findFirstOrThrow
   */
  export type turmasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the turmas
     */
    select?: turmasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: turmasInclude | null
    /**
     * Filter, which turmas to fetch.
     */
    where?: turmasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of turmas to fetch.
     */
    orderBy?: Enumerable<turmasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for turmas.
     */
    cursor?: turmasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` turmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of turmas.
     */
    distinct?: Enumerable<TurmasScalarFieldEnum>
  }


  /**
   * turmas findMany
   */
  export type turmasFindManyArgs = {
    /**
     * Select specific fields to fetch from the turmas
     */
    select?: turmasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: turmasInclude | null
    /**
     * Filter, which turmas to fetch.
     */
    where?: turmasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of turmas to fetch.
     */
    orderBy?: Enumerable<turmasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing turmas.
     */
    cursor?: turmasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` turmas.
     */
    skip?: number
    distinct?: Enumerable<TurmasScalarFieldEnum>
  }


  /**
   * turmas create
   */
  export type turmasCreateArgs = {
    /**
     * Select specific fields to fetch from the turmas
     */
    select?: turmasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: turmasInclude | null
    /**
     * The data needed to create a turmas.
     */
    data: XOR<turmasCreateInput, turmasUncheckedCreateInput>
  }


  /**
   * turmas createMany
   */
  export type turmasCreateManyArgs = {
    /**
     * The data used to create many turmas.
     */
    data: Enumerable<turmasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * turmas update
   */
  export type turmasUpdateArgs = {
    /**
     * Select specific fields to fetch from the turmas
     */
    select?: turmasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: turmasInclude | null
    /**
     * The data needed to update a turmas.
     */
    data: XOR<turmasUpdateInput, turmasUncheckedUpdateInput>
    /**
     * Choose, which turmas to update.
     */
    where: turmasWhereUniqueInput
  }


  /**
   * turmas updateMany
   */
  export type turmasUpdateManyArgs = {
    /**
     * The data used to update turmas.
     */
    data: XOR<turmasUpdateManyMutationInput, turmasUncheckedUpdateManyInput>
    /**
     * Filter which turmas to update
     */
    where?: turmasWhereInput
  }


  /**
   * turmas upsert
   */
  export type turmasUpsertArgs = {
    /**
     * Select specific fields to fetch from the turmas
     */
    select?: turmasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: turmasInclude | null
    /**
     * The filter to search for the turmas to update in case it exists.
     */
    where: turmasWhereUniqueInput
    /**
     * In case the turmas found by the `where` argument doesn't exist, create a new turmas with this data.
     */
    create: XOR<turmasCreateInput, turmasUncheckedCreateInput>
    /**
     * In case the turmas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<turmasUpdateInput, turmasUncheckedUpdateInput>
  }


  /**
   * turmas delete
   */
  export type turmasDeleteArgs = {
    /**
     * Select specific fields to fetch from the turmas
     */
    select?: turmasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: turmasInclude | null
    /**
     * Filter which turmas to delete.
     */
    where: turmasWhereUniqueInput
  }


  /**
   * turmas deleteMany
   */
  export type turmasDeleteManyArgs = {
    /**
     * Filter which turmas to delete
     */
    where?: turmasWhereInput
  }


  /**
   * turmas.professores
   */
  export type turmas$professoresArgs = {
    /**
     * Select specific fields to fetch from the professores
     */
    select?: professoresSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: professoresInclude | null
    where?: professoresWhereInput
    orderBy?: Enumerable<professoresOrderByWithRelationInput>
    cursor?: professoresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProfessoresScalarFieldEnum>
  }


  /**
   * turmas.alunos
   */
  export type turmas$alunosArgs = {
    /**
     * Select specific fields to fetch from the alunos
     */
    select?: alunosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: alunosInclude | null
    where?: alunosWhereInput
    orderBy?: Enumerable<alunosOrderByWithRelationInput>
    cursor?: alunosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AlunosScalarFieldEnum>
  }


  /**
   * turmas.atividades
   */
  export type turmas$atividadesArgs = {
    /**
     * Select specific fields to fetch from the atividades
     */
    select?: atividadesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: atividadesInclude | null
    where?: atividadesWhereInput
    orderBy?: Enumerable<atividadesOrderByWithRelationInput>
    cursor?: atividadesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AtividadesScalarFieldEnum>
  }


  /**
   * turmas.pontos
   */
  export type turmas$pontosArgs = {
    /**
     * Select specific fields to fetch from the pontos
     */
    select?: pontosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pontosInclude | null
    where?: pontosWhereInput
    orderBy?: Enumerable<pontosOrderByWithRelationInput>
    cursor?: pontosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PontosScalarFieldEnum>
  }


  /**
   * turmas.premios
   */
  export type turmas$premiosArgs = {
    /**
     * Select specific fields to fetch from the premios
     */
    select?: premiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: premiosInclude | null
    where?: premiosWhereInput
    orderBy?: Enumerable<premiosOrderByWithRelationInput>
    cursor?: premiosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PremiosScalarFieldEnum>
  }


  /**
   * turmas without action
   */
  export type turmasArgs = {
    /**
     * Select specific fields to fetch from the turmas
     */
    select?: turmasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: turmasInclude | null
  }



  /**
   * Model premios
   */


  export type AggregatePremios = {
    _count: PremiosCountAggregateOutputType | null
    _avg: PremiosAvgAggregateOutputType | null
    _sum: PremiosSumAggregateOutputType | null
    _min: PremiosMinAggregateOutputType | null
    _max: PremiosMaxAggregateOutputType | null
  }

  export type PremiosAvgAggregateOutputType = {
    id_premio: number | null
    id_turma: number | null
    pontos_requeridos: number | null
  }

  export type PremiosSumAggregateOutputType = {
    id_premio: number | null
    id_turma: number | null
    pontos_requeridos: number | null
  }

  export type PremiosMinAggregateOutputType = {
    id_premio: number | null
    id_turma: number | null
    descricao: string | null
    pontos_requeridos: number | null
  }

  export type PremiosMaxAggregateOutputType = {
    id_premio: number | null
    id_turma: number | null
    descricao: string | null
    pontos_requeridos: number | null
  }

  export type PremiosCountAggregateOutputType = {
    id_premio: number
    id_turma: number
    descricao: number
    pontos_requeridos: number
    _all: number
  }


  export type PremiosAvgAggregateInputType = {
    id_premio?: true
    id_turma?: true
    pontos_requeridos?: true
  }

  export type PremiosSumAggregateInputType = {
    id_premio?: true
    id_turma?: true
    pontos_requeridos?: true
  }

  export type PremiosMinAggregateInputType = {
    id_premio?: true
    id_turma?: true
    descricao?: true
    pontos_requeridos?: true
  }

  export type PremiosMaxAggregateInputType = {
    id_premio?: true
    id_turma?: true
    descricao?: true
    pontos_requeridos?: true
  }

  export type PremiosCountAggregateInputType = {
    id_premio?: true
    id_turma?: true
    descricao?: true
    pontos_requeridos?: true
    _all?: true
  }

  export type PremiosAggregateArgs = {
    /**
     * Filter which premios to aggregate.
     */
    where?: premiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of premios to fetch.
     */
    orderBy?: Enumerable<premiosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: premiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` premios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` premios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned premios
    **/
    _count?: true | PremiosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PremiosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PremiosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PremiosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PremiosMaxAggregateInputType
  }

  export type GetPremiosAggregateType<T extends PremiosAggregateArgs> = {
        [P in keyof T & keyof AggregatePremios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePremios[P]>
      : GetScalarType<T[P], AggregatePremios[P]>
  }




  export type PremiosGroupByArgs = {
    where?: premiosWhereInput
    orderBy?: Enumerable<premiosOrderByWithAggregationInput>
    by: PremiosScalarFieldEnum[]
    having?: premiosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PremiosCountAggregateInputType | true
    _avg?: PremiosAvgAggregateInputType
    _sum?: PremiosSumAggregateInputType
    _min?: PremiosMinAggregateInputType
    _max?: PremiosMaxAggregateInputType
  }


  export type PremiosGroupByOutputType = {
    id_premio: number
    id_turma: number
    descricao: string
    pontos_requeridos: number
    _count: PremiosCountAggregateOutputType | null
    _avg: PremiosAvgAggregateOutputType | null
    _sum: PremiosSumAggregateOutputType | null
    _min: PremiosMinAggregateOutputType | null
    _max: PremiosMaxAggregateOutputType | null
  }

  type GetPremiosGroupByPayload<T extends PremiosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PremiosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PremiosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PremiosGroupByOutputType[P]>
            : GetScalarType<T[P], PremiosGroupByOutputType[P]>
        }
      >
    >


  export type premiosSelect = {
    id_premio?: boolean
    id_turma?: boolean
    descricao?: boolean
    pontos_requeridos?: boolean
    turma?: boolean | turmasArgs
  }


  export type premiosInclude = {
    turma?: boolean | turmasArgs
  }

  export type premiosGetPayload<S extends boolean | null | undefined | premiosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? premios :
    S extends undefined ? never :
    S extends { include: any } & (premiosArgs | premiosFindManyArgs)
    ? premios  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'turma' ? turmasGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (premiosArgs | premiosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'turma' ? turmasGetPayload<S['select'][P]> :  P extends keyof premios ? premios[P] : never
  } 
      : premios


  type premiosCountArgs = 
    Omit<premiosFindManyArgs, 'select' | 'include'> & {
      select?: PremiosCountAggregateInputType | true
    }

  export interface premiosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Premios that matches the filter.
     * @param {premiosFindUniqueArgs} args - Arguments to find a Premios
     * @example
     * // Get one Premios
     * const premios = await prisma.premios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends premiosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, premiosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'premios'> extends True ? Prisma__premiosClient<premiosGetPayload<T>> : Prisma__premiosClient<premiosGetPayload<T> | null, null>

    /**
     * Find one Premios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {premiosFindUniqueOrThrowArgs} args - Arguments to find a Premios
     * @example
     * // Get one Premios
     * const premios = await prisma.premios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends premiosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, premiosFindUniqueOrThrowArgs>
    ): Prisma__premiosClient<premiosGetPayload<T>>

    /**
     * Find the first Premios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {premiosFindFirstArgs} args - Arguments to find a Premios
     * @example
     * // Get one Premios
     * const premios = await prisma.premios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends premiosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, premiosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'premios'> extends True ? Prisma__premiosClient<premiosGetPayload<T>> : Prisma__premiosClient<premiosGetPayload<T> | null, null>

    /**
     * Find the first Premios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {premiosFindFirstOrThrowArgs} args - Arguments to find a Premios
     * @example
     * // Get one Premios
     * const premios = await prisma.premios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends premiosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, premiosFindFirstOrThrowArgs>
    ): Prisma__premiosClient<premiosGetPayload<T>>

    /**
     * Find zero or more Premios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {premiosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Premios
     * const premios = await prisma.premios.findMany()
     * 
     * // Get first 10 Premios
     * const premios = await prisma.premios.findMany({ take: 10 })
     * 
     * // Only select the `id_premio`
     * const premiosWithId_premioOnly = await prisma.premios.findMany({ select: { id_premio: true } })
     * 
    **/
    findMany<T extends premiosFindManyArgs>(
      args?: SelectSubset<T, premiosFindManyArgs>
    ): Prisma.PrismaPromise<Array<premiosGetPayload<T>>>

    /**
     * Create a Premios.
     * @param {premiosCreateArgs} args - Arguments to create a Premios.
     * @example
     * // Create one Premios
     * const Premios = await prisma.premios.create({
     *   data: {
     *     // ... data to create a Premios
     *   }
     * })
     * 
    **/
    create<T extends premiosCreateArgs>(
      args: SelectSubset<T, premiosCreateArgs>
    ): Prisma__premiosClient<premiosGetPayload<T>>

    /**
     * Create many Premios.
     *     @param {premiosCreateManyArgs} args - Arguments to create many Premios.
     *     @example
     *     // Create many Premios
     *     const premios = await prisma.premios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends premiosCreateManyArgs>(
      args?: SelectSubset<T, premiosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Premios.
     * @param {premiosDeleteArgs} args - Arguments to delete one Premios.
     * @example
     * // Delete one Premios
     * const Premios = await prisma.premios.delete({
     *   where: {
     *     // ... filter to delete one Premios
     *   }
     * })
     * 
    **/
    delete<T extends premiosDeleteArgs>(
      args: SelectSubset<T, premiosDeleteArgs>
    ): Prisma__premiosClient<premiosGetPayload<T>>

    /**
     * Update one Premios.
     * @param {premiosUpdateArgs} args - Arguments to update one Premios.
     * @example
     * // Update one Premios
     * const premios = await prisma.premios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends premiosUpdateArgs>(
      args: SelectSubset<T, premiosUpdateArgs>
    ): Prisma__premiosClient<premiosGetPayload<T>>

    /**
     * Delete zero or more Premios.
     * @param {premiosDeleteManyArgs} args - Arguments to filter Premios to delete.
     * @example
     * // Delete a few Premios
     * const { count } = await prisma.premios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends premiosDeleteManyArgs>(
      args?: SelectSubset<T, premiosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Premios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {premiosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Premios
     * const premios = await prisma.premios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends premiosUpdateManyArgs>(
      args: SelectSubset<T, premiosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Premios.
     * @param {premiosUpsertArgs} args - Arguments to update or create a Premios.
     * @example
     * // Update or create a Premios
     * const premios = await prisma.premios.upsert({
     *   create: {
     *     // ... data to create a Premios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Premios we want to update
     *   }
     * })
    **/
    upsert<T extends premiosUpsertArgs>(
      args: SelectSubset<T, premiosUpsertArgs>
    ): Prisma__premiosClient<premiosGetPayload<T>>

    /**
     * Count the number of Premios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {premiosCountArgs} args - Arguments to filter Premios to count.
     * @example
     * // Count the number of Premios
     * const count = await prisma.premios.count({
     *   where: {
     *     // ... the filter for the Premios we want to count
     *   }
     * })
    **/
    count<T extends premiosCountArgs>(
      args?: Subset<T, premiosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PremiosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Premios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremiosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PremiosAggregateArgs>(args: Subset<T, PremiosAggregateArgs>): Prisma.PrismaPromise<GetPremiosAggregateType<T>>

    /**
     * Group by Premios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremiosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PremiosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PremiosGroupByArgs['orderBy'] }
        : { orderBy?: PremiosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PremiosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPremiosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for premios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__premiosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    turma<T extends turmasArgs= {}>(args?: Subset<T, turmasArgs>): Prisma__turmasClient<turmasGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * premios base type for findUnique actions
   */
  export type premiosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the premios
     */
    select?: premiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: premiosInclude | null
    /**
     * Filter, which premios to fetch.
     */
    where: premiosWhereUniqueInput
  }

  /**
   * premios findUnique
   */
  export interface premiosFindUniqueArgs extends premiosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * premios findUniqueOrThrow
   */
  export type premiosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the premios
     */
    select?: premiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: premiosInclude | null
    /**
     * Filter, which premios to fetch.
     */
    where: premiosWhereUniqueInput
  }


  /**
   * premios base type for findFirst actions
   */
  export type premiosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the premios
     */
    select?: premiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: premiosInclude | null
    /**
     * Filter, which premios to fetch.
     */
    where?: premiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of premios to fetch.
     */
    orderBy?: Enumerable<premiosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for premios.
     */
    cursor?: premiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` premios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` premios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of premios.
     */
    distinct?: Enumerable<PremiosScalarFieldEnum>
  }

  /**
   * premios findFirst
   */
  export interface premiosFindFirstArgs extends premiosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * premios findFirstOrThrow
   */
  export type premiosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the premios
     */
    select?: premiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: premiosInclude | null
    /**
     * Filter, which premios to fetch.
     */
    where?: premiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of premios to fetch.
     */
    orderBy?: Enumerable<premiosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for premios.
     */
    cursor?: premiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` premios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` premios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of premios.
     */
    distinct?: Enumerable<PremiosScalarFieldEnum>
  }


  /**
   * premios findMany
   */
  export type premiosFindManyArgs = {
    /**
     * Select specific fields to fetch from the premios
     */
    select?: premiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: premiosInclude | null
    /**
     * Filter, which premios to fetch.
     */
    where?: premiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of premios to fetch.
     */
    orderBy?: Enumerable<premiosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing premios.
     */
    cursor?: premiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` premios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` premios.
     */
    skip?: number
    distinct?: Enumerable<PremiosScalarFieldEnum>
  }


  /**
   * premios create
   */
  export type premiosCreateArgs = {
    /**
     * Select specific fields to fetch from the premios
     */
    select?: premiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: premiosInclude | null
    /**
     * The data needed to create a premios.
     */
    data: XOR<premiosCreateInput, premiosUncheckedCreateInput>
  }


  /**
   * premios createMany
   */
  export type premiosCreateManyArgs = {
    /**
     * The data used to create many premios.
     */
    data: Enumerable<premiosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * premios update
   */
  export type premiosUpdateArgs = {
    /**
     * Select specific fields to fetch from the premios
     */
    select?: premiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: premiosInclude | null
    /**
     * The data needed to update a premios.
     */
    data: XOR<premiosUpdateInput, premiosUncheckedUpdateInput>
    /**
     * Choose, which premios to update.
     */
    where: premiosWhereUniqueInput
  }


  /**
   * premios updateMany
   */
  export type premiosUpdateManyArgs = {
    /**
     * The data used to update premios.
     */
    data: XOR<premiosUpdateManyMutationInput, premiosUncheckedUpdateManyInput>
    /**
     * Filter which premios to update
     */
    where?: premiosWhereInput
  }


  /**
   * premios upsert
   */
  export type premiosUpsertArgs = {
    /**
     * Select specific fields to fetch from the premios
     */
    select?: premiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: premiosInclude | null
    /**
     * The filter to search for the premios to update in case it exists.
     */
    where: premiosWhereUniqueInput
    /**
     * In case the premios found by the `where` argument doesn't exist, create a new premios with this data.
     */
    create: XOR<premiosCreateInput, premiosUncheckedCreateInput>
    /**
     * In case the premios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<premiosUpdateInput, premiosUncheckedUpdateInput>
  }


  /**
   * premios delete
   */
  export type premiosDeleteArgs = {
    /**
     * Select specific fields to fetch from the premios
     */
    select?: premiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: premiosInclude | null
    /**
     * Filter which premios to delete.
     */
    where: premiosWhereUniqueInput
  }


  /**
   * premios deleteMany
   */
  export type premiosDeleteManyArgs = {
    /**
     * Filter which premios to delete
     */
    where?: premiosWhereInput
  }


  /**
   * premios without action
   */
  export type premiosArgs = {
    /**
     * Select specific fields to fetch from the premios
     */
    select?: premiosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: premiosInclude | null
  }



  /**
   * Model pontos
   */


  export type AggregatePontos = {
    _count: PontosCountAggregateOutputType | null
    _avg: PontosAvgAggregateOutputType | null
    _sum: PontosSumAggregateOutputType | null
    _min: PontosMinAggregateOutputType | null
    _max: PontosMaxAggregateOutputType | null
  }

  export type PontosAvgAggregateOutputType = {
    id_ponto: number | null
    id_aluno: number | null
    id_turma: number | null
    qtd: number | null
  }

  export type PontosSumAggregateOutputType = {
    id_ponto: number | null
    id_aluno: number | null
    id_turma: number | null
    qtd: number | null
  }

  export type PontosMinAggregateOutputType = {
    id_ponto: number | null
    id_aluno: number | null
    id_turma: number | null
    qtd: number | null
  }

  export type PontosMaxAggregateOutputType = {
    id_ponto: number | null
    id_aluno: number | null
    id_turma: number | null
    qtd: number | null
  }

  export type PontosCountAggregateOutputType = {
    id_ponto: number
    id_aluno: number
    id_turma: number
    qtd: number
    _all: number
  }


  export type PontosAvgAggregateInputType = {
    id_ponto?: true
    id_aluno?: true
    id_turma?: true
    qtd?: true
  }

  export type PontosSumAggregateInputType = {
    id_ponto?: true
    id_aluno?: true
    id_turma?: true
    qtd?: true
  }

  export type PontosMinAggregateInputType = {
    id_ponto?: true
    id_aluno?: true
    id_turma?: true
    qtd?: true
  }

  export type PontosMaxAggregateInputType = {
    id_ponto?: true
    id_aluno?: true
    id_turma?: true
    qtd?: true
  }

  export type PontosCountAggregateInputType = {
    id_ponto?: true
    id_aluno?: true
    id_turma?: true
    qtd?: true
    _all?: true
  }

  export type PontosAggregateArgs = {
    /**
     * Filter which pontos to aggregate.
     */
    where?: pontosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pontos to fetch.
     */
    orderBy?: Enumerable<pontosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pontosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pontos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pontos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pontos
    **/
    _count?: true | PontosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PontosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PontosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PontosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PontosMaxAggregateInputType
  }

  export type GetPontosAggregateType<T extends PontosAggregateArgs> = {
        [P in keyof T & keyof AggregatePontos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePontos[P]>
      : GetScalarType<T[P], AggregatePontos[P]>
  }




  export type PontosGroupByArgs = {
    where?: pontosWhereInput
    orderBy?: Enumerable<pontosOrderByWithAggregationInput>
    by: PontosScalarFieldEnum[]
    having?: pontosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PontosCountAggregateInputType | true
    _avg?: PontosAvgAggregateInputType
    _sum?: PontosSumAggregateInputType
    _min?: PontosMinAggregateInputType
    _max?: PontosMaxAggregateInputType
  }


  export type PontosGroupByOutputType = {
    id_ponto: number
    id_aluno: number
    id_turma: number
    qtd: number | null
    _count: PontosCountAggregateOutputType | null
    _avg: PontosAvgAggregateOutputType | null
    _sum: PontosSumAggregateOutputType | null
    _min: PontosMinAggregateOutputType | null
    _max: PontosMaxAggregateOutputType | null
  }

  type GetPontosGroupByPayload<T extends PontosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PontosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PontosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PontosGroupByOutputType[P]>
            : GetScalarType<T[P], PontosGroupByOutputType[P]>
        }
      >
    >


  export type pontosSelect = {
    id_ponto?: boolean
    id_aluno?: boolean
    id_turma?: boolean
    qtd?: boolean
    alunos?: boolean | alunosArgs
    turma?: boolean | turmasArgs
  }


  export type pontosInclude = {
    alunos?: boolean | alunosArgs
    turma?: boolean | turmasArgs
  }

  export type pontosGetPayload<S extends boolean | null | undefined | pontosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pontos :
    S extends undefined ? never :
    S extends { include: any } & (pontosArgs | pontosFindManyArgs)
    ? pontos  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'alunos' ? alunosGetPayload<S['include'][P]> :
        P extends 'turma' ? turmasGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (pontosArgs | pontosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'alunos' ? alunosGetPayload<S['select'][P]> :
        P extends 'turma' ? turmasGetPayload<S['select'][P]> :  P extends keyof pontos ? pontos[P] : never
  } 
      : pontos


  type pontosCountArgs = 
    Omit<pontosFindManyArgs, 'select' | 'include'> & {
      select?: PontosCountAggregateInputType | true
    }

  export interface pontosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Pontos that matches the filter.
     * @param {pontosFindUniqueArgs} args - Arguments to find a Pontos
     * @example
     * // Get one Pontos
     * const pontos = await prisma.pontos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pontosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pontosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pontos'> extends True ? Prisma__pontosClient<pontosGetPayload<T>> : Prisma__pontosClient<pontosGetPayload<T> | null, null>

    /**
     * Find one Pontos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pontosFindUniqueOrThrowArgs} args - Arguments to find a Pontos
     * @example
     * // Get one Pontos
     * const pontos = await prisma.pontos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pontosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pontosFindUniqueOrThrowArgs>
    ): Prisma__pontosClient<pontosGetPayload<T>>

    /**
     * Find the first Pontos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pontosFindFirstArgs} args - Arguments to find a Pontos
     * @example
     * // Get one Pontos
     * const pontos = await prisma.pontos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pontosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pontosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pontos'> extends True ? Prisma__pontosClient<pontosGetPayload<T>> : Prisma__pontosClient<pontosGetPayload<T> | null, null>

    /**
     * Find the first Pontos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pontosFindFirstOrThrowArgs} args - Arguments to find a Pontos
     * @example
     * // Get one Pontos
     * const pontos = await prisma.pontos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pontosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pontosFindFirstOrThrowArgs>
    ): Prisma__pontosClient<pontosGetPayload<T>>

    /**
     * Find zero or more Pontos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pontosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pontos
     * const pontos = await prisma.pontos.findMany()
     * 
     * // Get first 10 Pontos
     * const pontos = await prisma.pontos.findMany({ take: 10 })
     * 
     * // Only select the `id_ponto`
     * const pontosWithId_pontoOnly = await prisma.pontos.findMany({ select: { id_ponto: true } })
     * 
    **/
    findMany<T extends pontosFindManyArgs>(
      args?: SelectSubset<T, pontosFindManyArgs>
    ): Prisma.PrismaPromise<Array<pontosGetPayload<T>>>

    /**
     * Create a Pontos.
     * @param {pontosCreateArgs} args - Arguments to create a Pontos.
     * @example
     * // Create one Pontos
     * const Pontos = await prisma.pontos.create({
     *   data: {
     *     // ... data to create a Pontos
     *   }
     * })
     * 
    **/
    create<T extends pontosCreateArgs>(
      args: SelectSubset<T, pontosCreateArgs>
    ): Prisma__pontosClient<pontosGetPayload<T>>

    /**
     * Create many Pontos.
     *     @param {pontosCreateManyArgs} args - Arguments to create many Pontos.
     *     @example
     *     // Create many Pontos
     *     const pontos = await prisma.pontos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pontosCreateManyArgs>(
      args?: SelectSubset<T, pontosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pontos.
     * @param {pontosDeleteArgs} args - Arguments to delete one Pontos.
     * @example
     * // Delete one Pontos
     * const Pontos = await prisma.pontos.delete({
     *   where: {
     *     // ... filter to delete one Pontos
     *   }
     * })
     * 
    **/
    delete<T extends pontosDeleteArgs>(
      args: SelectSubset<T, pontosDeleteArgs>
    ): Prisma__pontosClient<pontosGetPayload<T>>

    /**
     * Update one Pontos.
     * @param {pontosUpdateArgs} args - Arguments to update one Pontos.
     * @example
     * // Update one Pontos
     * const pontos = await prisma.pontos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pontosUpdateArgs>(
      args: SelectSubset<T, pontosUpdateArgs>
    ): Prisma__pontosClient<pontosGetPayload<T>>

    /**
     * Delete zero or more Pontos.
     * @param {pontosDeleteManyArgs} args - Arguments to filter Pontos to delete.
     * @example
     * // Delete a few Pontos
     * const { count } = await prisma.pontos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pontosDeleteManyArgs>(
      args?: SelectSubset<T, pontosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pontos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pontosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pontos
     * const pontos = await prisma.pontos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pontosUpdateManyArgs>(
      args: SelectSubset<T, pontosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pontos.
     * @param {pontosUpsertArgs} args - Arguments to update or create a Pontos.
     * @example
     * // Update or create a Pontos
     * const pontos = await prisma.pontos.upsert({
     *   create: {
     *     // ... data to create a Pontos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pontos we want to update
     *   }
     * })
    **/
    upsert<T extends pontosUpsertArgs>(
      args: SelectSubset<T, pontosUpsertArgs>
    ): Prisma__pontosClient<pontosGetPayload<T>>

    /**
     * Count the number of Pontos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pontosCountArgs} args - Arguments to filter Pontos to count.
     * @example
     * // Count the number of Pontos
     * const count = await prisma.pontos.count({
     *   where: {
     *     // ... the filter for the Pontos we want to count
     *   }
     * })
    **/
    count<T extends pontosCountArgs>(
      args?: Subset<T, pontosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PontosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pontos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PontosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PontosAggregateArgs>(args: Subset<T, PontosAggregateArgs>): Prisma.PrismaPromise<GetPontosAggregateType<T>>

    /**
     * Group by Pontos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PontosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PontosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PontosGroupByArgs['orderBy'] }
        : { orderBy?: PontosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PontosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPontosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pontos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pontosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    alunos<T extends alunosArgs= {}>(args?: Subset<T, alunosArgs>): Prisma__alunosClient<alunosGetPayload<T> | Null>;

    turma<T extends turmasArgs= {}>(args?: Subset<T, turmasArgs>): Prisma__turmasClient<turmasGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pontos base type for findUnique actions
   */
  export type pontosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pontos
     */
    select?: pontosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pontosInclude | null
    /**
     * Filter, which pontos to fetch.
     */
    where: pontosWhereUniqueInput
  }

  /**
   * pontos findUnique
   */
  export interface pontosFindUniqueArgs extends pontosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pontos findUniqueOrThrow
   */
  export type pontosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pontos
     */
    select?: pontosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pontosInclude | null
    /**
     * Filter, which pontos to fetch.
     */
    where: pontosWhereUniqueInput
  }


  /**
   * pontos base type for findFirst actions
   */
  export type pontosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pontos
     */
    select?: pontosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pontosInclude | null
    /**
     * Filter, which pontos to fetch.
     */
    where?: pontosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pontos to fetch.
     */
    orderBy?: Enumerable<pontosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pontos.
     */
    cursor?: pontosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pontos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pontos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pontos.
     */
    distinct?: Enumerable<PontosScalarFieldEnum>
  }

  /**
   * pontos findFirst
   */
  export interface pontosFindFirstArgs extends pontosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pontos findFirstOrThrow
   */
  export type pontosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pontos
     */
    select?: pontosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pontosInclude | null
    /**
     * Filter, which pontos to fetch.
     */
    where?: pontosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pontos to fetch.
     */
    orderBy?: Enumerable<pontosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pontos.
     */
    cursor?: pontosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pontos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pontos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pontos.
     */
    distinct?: Enumerable<PontosScalarFieldEnum>
  }


  /**
   * pontos findMany
   */
  export type pontosFindManyArgs = {
    /**
     * Select specific fields to fetch from the pontos
     */
    select?: pontosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pontosInclude | null
    /**
     * Filter, which pontos to fetch.
     */
    where?: pontosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pontos to fetch.
     */
    orderBy?: Enumerable<pontosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pontos.
     */
    cursor?: pontosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pontos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pontos.
     */
    skip?: number
    distinct?: Enumerable<PontosScalarFieldEnum>
  }


  /**
   * pontos create
   */
  export type pontosCreateArgs = {
    /**
     * Select specific fields to fetch from the pontos
     */
    select?: pontosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pontosInclude | null
    /**
     * The data needed to create a pontos.
     */
    data: XOR<pontosCreateInput, pontosUncheckedCreateInput>
  }


  /**
   * pontos createMany
   */
  export type pontosCreateManyArgs = {
    /**
     * The data used to create many pontos.
     */
    data: Enumerable<pontosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pontos update
   */
  export type pontosUpdateArgs = {
    /**
     * Select specific fields to fetch from the pontos
     */
    select?: pontosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pontosInclude | null
    /**
     * The data needed to update a pontos.
     */
    data: XOR<pontosUpdateInput, pontosUncheckedUpdateInput>
    /**
     * Choose, which pontos to update.
     */
    where: pontosWhereUniqueInput
  }


  /**
   * pontos updateMany
   */
  export type pontosUpdateManyArgs = {
    /**
     * The data used to update pontos.
     */
    data: XOR<pontosUpdateManyMutationInput, pontosUncheckedUpdateManyInput>
    /**
     * Filter which pontos to update
     */
    where?: pontosWhereInput
  }


  /**
   * pontos upsert
   */
  export type pontosUpsertArgs = {
    /**
     * Select specific fields to fetch from the pontos
     */
    select?: pontosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pontosInclude | null
    /**
     * The filter to search for the pontos to update in case it exists.
     */
    where: pontosWhereUniqueInput
    /**
     * In case the pontos found by the `where` argument doesn't exist, create a new pontos with this data.
     */
    create: XOR<pontosCreateInput, pontosUncheckedCreateInput>
    /**
     * In case the pontos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pontosUpdateInput, pontosUncheckedUpdateInput>
  }


  /**
   * pontos delete
   */
  export type pontosDeleteArgs = {
    /**
     * Select specific fields to fetch from the pontos
     */
    select?: pontosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pontosInclude | null
    /**
     * Filter which pontos to delete.
     */
    where: pontosWhereUniqueInput
  }


  /**
   * pontos deleteMany
   */
  export type pontosDeleteManyArgs = {
    /**
     * Filter which pontos to delete
     */
    where?: pontosWhereInput
  }


  /**
   * pontos without action
   */
  export type pontosArgs = {
    /**
     * Select specific fields to fetch from the pontos
     */
    select?: pontosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pontosInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AlunosScalarFieldEnum: {
    id_aluno: 'id_aluno',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    nivel_de_acesso: 'nivel_de_acesso'
  };

  export type AlunosScalarFieldEnum = (typeof AlunosScalarFieldEnum)[keyof typeof AlunosScalarFieldEnum]


  export const AtividadesScalarFieldEnum: {
    id_atividade: 'id_atividade',
    id_turma: 'id_turma',
    titulo: 'titulo',
    descricao: 'descricao',
    prazo: 'prazo',
    pontos_conclusao: 'pontos_conclusao'
  };

  export type AtividadesScalarFieldEnum = (typeof AtividadesScalarFieldEnum)[keyof typeof AtividadesScalarFieldEnum]


  export const Atividades_concluidasScalarFieldEnum: {
    id_concluida: 'id_concluida',
    id_atividade: 'id_atividade',
    id_aluno: 'id_aluno',
    data_concluida: 'data_concluida',
    arquivo: 'arquivo'
  };

  export type Atividades_concluidasScalarFieldEnum = (typeof Atividades_concluidasScalarFieldEnum)[keyof typeof Atividades_concluidasScalarFieldEnum]


  export const PontosScalarFieldEnum: {
    id_ponto: 'id_ponto',
    id_aluno: 'id_aluno',
    id_turma: 'id_turma',
    qtd: 'qtd'
  };

  export type PontosScalarFieldEnum = (typeof PontosScalarFieldEnum)[keyof typeof PontosScalarFieldEnum]


  export const PremiosScalarFieldEnum: {
    id_premio: 'id_premio',
    id_turma: 'id_turma',
    descricao: 'descricao',
    pontos_requeridos: 'pontos_requeridos'
  };

  export type PremiosScalarFieldEnum = (typeof PremiosScalarFieldEnum)[keyof typeof PremiosScalarFieldEnum]


  export const ProfessoresScalarFieldEnum: {
    id_prof: 'id_prof',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    nivel_de_acesso: 'nivel_de_acesso'
  };

  export type ProfessoresScalarFieldEnum = (typeof ProfessoresScalarFieldEnum)[keyof typeof ProfessoresScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TurmasScalarFieldEnum: {
    id_turma: 'id_turma',
    nome: 'nome',
    codigo: 'codigo'
  };

  export type TurmasScalarFieldEnum = (typeof TurmasScalarFieldEnum)[keyof typeof TurmasScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type alunosWhereInput = {
    AND?: Enumerable<alunosWhereInput>
    OR?: Enumerable<alunosWhereInput>
    NOT?: Enumerable<alunosWhereInput>
    id_aluno?: IntFilter | number
    nome?: StringFilter | string
    email?: StringFilter | string
    senha?: StringFilter | string
    nivel_de_acesso?: StringNullableFilter | string | null
    turma?: TurmasListRelationFilter
    pontos?: PontosListRelationFilter
    atividades_concluidas?: Atividades_concluidasListRelationFilter
  }

  export type alunosOrderByWithRelationInput = {
    id_aluno?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel_de_acesso?: SortOrder
    turma?: turmasOrderByRelationAggregateInput
    pontos?: pontosOrderByRelationAggregateInput
    atividades_concluidas?: atividades_concluidasOrderByRelationAggregateInput
  }

  export type alunosWhereUniqueInput = {
    id_aluno?: number
    email?: string
  }

  export type alunosOrderByWithAggregationInput = {
    id_aluno?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel_de_acesso?: SortOrder
    _count?: alunosCountOrderByAggregateInput
    _avg?: alunosAvgOrderByAggregateInput
    _max?: alunosMaxOrderByAggregateInput
    _min?: alunosMinOrderByAggregateInput
    _sum?: alunosSumOrderByAggregateInput
  }

  export type alunosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<alunosScalarWhereWithAggregatesInput>
    OR?: Enumerable<alunosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<alunosScalarWhereWithAggregatesInput>
    id_aluno?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    senha?: StringWithAggregatesFilter | string
    nivel_de_acesso?: StringNullableWithAggregatesFilter | string | null
  }

  export type professoresWhereInput = {
    AND?: Enumerable<professoresWhereInput>
    OR?: Enumerable<professoresWhereInput>
    NOT?: Enumerable<professoresWhereInput>
    id_prof?: IntFilter | number
    nome?: StringFilter | string
    email?: StringFilter | string
    senha?: StringFilter | string
    nivel_de_acesso?: StringNullableFilter | string | null
    turma?: TurmasListRelationFilter
  }

  export type professoresOrderByWithRelationInput = {
    id_prof?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel_de_acesso?: SortOrder
    turma?: turmasOrderByRelationAggregateInput
  }

  export type professoresWhereUniqueInput = {
    id_prof?: number
    email?: string
  }

  export type professoresOrderByWithAggregationInput = {
    id_prof?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel_de_acesso?: SortOrder
    _count?: professoresCountOrderByAggregateInput
    _avg?: professoresAvgOrderByAggregateInput
    _max?: professoresMaxOrderByAggregateInput
    _min?: professoresMinOrderByAggregateInput
    _sum?: professoresSumOrderByAggregateInput
  }

  export type professoresScalarWhereWithAggregatesInput = {
    AND?: Enumerable<professoresScalarWhereWithAggregatesInput>
    OR?: Enumerable<professoresScalarWhereWithAggregatesInput>
    NOT?: Enumerable<professoresScalarWhereWithAggregatesInput>
    id_prof?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    senha?: StringWithAggregatesFilter | string
    nivel_de_acesso?: StringNullableWithAggregatesFilter | string | null
  }

  export type atividadesWhereInput = {
    AND?: Enumerable<atividadesWhereInput>
    OR?: Enumerable<atividadesWhereInput>
    NOT?: Enumerable<atividadesWhereInput>
    id_atividade?: IntFilter | number
    id_turma?: IntFilter | number
    titulo?: StringFilter | string
    descricao?: StringFilter | string
    prazo?: DateTimeFilter | Date | string
    pontos_conclusao?: IntFilter | number
    turma?: XOR<TurmasRelationFilter, turmasWhereInput>
    atividades_concluidas?: Atividades_concluidasListRelationFilter
  }

  export type atividadesOrderByWithRelationInput = {
    id_atividade?: SortOrder
    id_turma?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    prazo?: SortOrder
    pontos_conclusao?: SortOrder
    turma?: turmasOrderByWithRelationInput
    atividades_concluidas?: atividades_concluidasOrderByRelationAggregateInput
  }

  export type atividadesWhereUniqueInput = {
    id_atividade?: number
  }

  export type atividadesOrderByWithAggregationInput = {
    id_atividade?: SortOrder
    id_turma?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    prazo?: SortOrder
    pontos_conclusao?: SortOrder
    _count?: atividadesCountOrderByAggregateInput
    _avg?: atividadesAvgOrderByAggregateInput
    _max?: atividadesMaxOrderByAggregateInput
    _min?: atividadesMinOrderByAggregateInput
    _sum?: atividadesSumOrderByAggregateInput
  }

  export type atividadesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<atividadesScalarWhereWithAggregatesInput>
    OR?: Enumerable<atividadesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<atividadesScalarWhereWithAggregatesInput>
    id_atividade?: IntWithAggregatesFilter | number
    id_turma?: IntWithAggregatesFilter | number
    titulo?: StringWithAggregatesFilter | string
    descricao?: StringWithAggregatesFilter | string
    prazo?: DateTimeWithAggregatesFilter | Date | string
    pontos_conclusao?: IntWithAggregatesFilter | number
  }

  export type atividades_concluidasWhereInput = {
    AND?: Enumerable<atividades_concluidasWhereInput>
    OR?: Enumerable<atividades_concluidasWhereInput>
    NOT?: Enumerable<atividades_concluidasWhereInput>
    id_concluida?: IntFilter | number
    id_atividade?: IntFilter | number
    id_aluno?: IntFilter | number
    data_concluida?: DateTimeFilter | Date | string
    arquivo?: StringFilter | string
    atividade?: XOR<AtividadesRelationFilter, atividadesWhereInput>
    aluno?: XOR<AlunosRelationFilter, alunosWhereInput>
  }

  export type atividades_concluidasOrderByWithRelationInput = {
    id_concluida?: SortOrder
    id_atividade?: SortOrder
    id_aluno?: SortOrder
    data_concluida?: SortOrder
    arquivo?: SortOrder
    atividade?: atividadesOrderByWithRelationInput
    aluno?: alunosOrderByWithRelationInput
  }

  export type atividades_concluidasWhereUniqueInput = {
    id_concluida?: number
  }

  export type atividades_concluidasOrderByWithAggregationInput = {
    id_concluida?: SortOrder
    id_atividade?: SortOrder
    id_aluno?: SortOrder
    data_concluida?: SortOrder
    arquivo?: SortOrder
    _count?: atividades_concluidasCountOrderByAggregateInput
    _avg?: atividades_concluidasAvgOrderByAggregateInput
    _max?: atividades_concluidasMaxOrderByAggregateInput
    _min?: atividades_concluidasMinOrderByAggregateInput
    _sum?: atividades_concluidasSumOrderByAggregateInput
  }

  export type atividades_concluidasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<atividades_concluidasScalarWhereWithAggregatesInput>
    OR?: Enumerable<atividades_concluidasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<atividades_concluidasScalarWhereWithAggregatesInput>
    id_concluida?: IntWithAggregatesFilter | number
    id_atividade?: IntWithAggregatesFilter | number
    id_aluno?: IntWithAggregatesFilter | number
    data_concluida?: DateTimeWithAggregatesFilter | Date | string
    arquivo?: StringWithAggregatesFilter | string
  }

  export type turmasWhereInput = {
    AND?: Enumerable<turmasWhereInput>
    OR?: Enumerable<turmasWhereInput>
    NOT?: Enumerable<turmasWhereInput>
    id_turma?: IntFilter | number
    nome?: StringFilter | string
    codigo?: StringFilter | string
    professores?: ProfessoresListRelationFilter
    alunos?: AlunosListRelationFilter
    atividades?: AtividadesListRelationFilter
    pontos?: PontosListRelationFilter
    premios?: PremiosListRelationFilter
  }

  export type turmasOrderByWithRelationInput = {
    id_turma?: SortOrder
    nome?: SortOrder
    codigo?: SortOrder
    professores?: professoresOrderByRelationAggregateInput
    alunos?: alunosOrderByRelationAggregateInput
    atividades?: atividadesOrderByRelationAggregateInput
    pontos?: pontosOrderByRelationAggregateInput
    premios?: premiosOrderByRelationAggregateInput
  }

  export type turmasWhereUniqueInput = {
    id_turma?: number
  }

  export type turmasOrderByWithAggregationInput = {
    id_turma?: SortOrder
    nome?: SortOrder
    codigo?: SortOrder
    _count?: turmasCountOrderByAggregateInput
    _avg?: turmasAvgOrderByAggregateInput
    _max?: turmasMaxOrderByAggregateInput
    _min?: turmasMinOrderByAggregateInput
    _sum?: turmasSumOrderByAggregateInput
  }

  export type turmasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<turmasScalarWhereWithAggregatesInput>
    OR?: Enumerable<turmasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<turmasScalarWhereWithAggregatesInput>
    id_turma?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
    codigo?: StringWithAggregatesFilter | string
  }

  export type premiosWhereInput = {
    AND?: Enumerable<premiosWhereInput>
    OR?: Enumerable<premiosWhereInput>
    NOT?: Enumerable<premiosWhereInput>
    id_premio?: IntFilter | number
    id_turma?: IntFilter | number
    descricao?: StringFilter | string
    pontos_requeridos?: FloatFilter | number
    turma?: XOR<TurmasRelationFilter, turmasWhereInput>
  }

  export type premiosOrderByWithRelationInput = {
    id_premio?: SortOrder
    id_turma?: SortOrder
    descricao?: SortOrder
    pontos_requeridos?: SortOrder
    turma?: turmasOrderByWithRelationInput
  }

  export type premiosWhereUniqueInput = {
    id_premio?: number
  }

  export type premiosOrderByWithAggregationInput = {
    id_premio?: SortOrder
    id_turma?: SortOrder
    descricao?: SortOrder
    pontos_requeridos?: SortOrder
    _count?: premiosCountOrderByAggregateInput
    _avg?: premiosAvgOrderByAggregateInput
    _max?: premiosMaxOrderByAggregateInput
    _min?: premiosMinOrderByAggregateInput
    _sum?: premiosSumOrderByAggregateInput
  }

  export type premiosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<premiosScalarWhereWithAggregatesInput>
    OR?: Enumerable<premiosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<premiosScalarWhereWithAggregatesInput>
    id_premio?: IntWithAggregatesFilter | number
    id_turma?: IntWithAggregatesFilter | number
    descricao?: StringWithAggregatesFilter | string
    pontos_requeridos?: FloatWithAggregatesFilter | number
  }

  export type pontosWhereInput = {
    AND?: Enumerable<pontosWhereInput>
    OR?: Enumerable<pontosWhereInput>
    NOT?: Enumerable<pontosWhereInput>
    id_ponto?: IntFilter | number
    id_aluno?: IntFilter | number
    id_turma?: IntFilter | number
    qtd?: FloatNullableFilter | number | null
    alunos?: XOR<AlunosRelationFilter, alunosWhereInput>
    turma?: XOR<TurmasRelationFilter, turmasWhereInput>
  }

  export type pontosOrderByWithRelationInput = {
    id_ponto?: SortOrder
    id_aluno?: SortOrder
    id_turma?: SortOrder
    qtd?: SortOrder
    alunos?: alunosOrderByWithRelationInput
    turma?: turmasOrderByWithRelationInput
  }

  export type pontosWhereUniqueInput = {
    id_ponto?: number
  }

  export type pontosOrderByWithAggregationInput = {
    id_ponto?: SortOrder
    id_aluno?: SortOrder
    id_turma?: SortOrder
    qtd?: SortOrder
    _count?: pontosCountOrderByAggregateInput
    _avg?: pontosAvgOrderByAggregateInput
    _max?: pontosMaxOrderByAggregateInput
    _min?: pontosMinOrderByAggregateInput
    _sum?: pontosSumOrderByAggregateInput
  }

  export type pontosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pontosScalarWhereWithAggregatesInput>
    OR?: Enumerable<pontosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pontosScalarWhereWithAggregatesInput>
    id_ponto?: IntWithAggregatesFilter | number
    id_aluno?: IntWithAggregatesFilter | number
    id_turma?: IntWithAggregatesFilter | number
    qtd?: FloatNullableWithAggregatesFilter | number | null
  }

  export type alunosCreateInput = {
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
    turma?: turmasCreateNestedManyWithoutAlunosInput
    pontos?: pontosCreateNestedManyWithoutAlunosInput
    atividades_concluidas?: atividades_concluidasCreateNestedManyWithoutAlunoInput
  }

  export type alunosUncheckedCreateInput = {
    id_aluno?: number
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
    turma?: turmasUncheckedCreateNestedManyWithoutAlunosInput
    pontos?: pontosUncheckedCreateNestedManyWithoutAlunosInput
    atividades_concluidas?: atividades_concluidasUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type alunosUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
    turma?: turmasUpdateManyWithoutAlunosNestedInput
    pontos?: pontosUpdateManyWithoutAlunosNestedInput
    atividades_concluidas?: atividades_concluidasUpdateManyWithoutAlunoNestedInput
  }

  export type alunosUncheckedUpdateInput = {
    id_aluno?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
    turma?: turmasUncheckedUpdateManyWithoutAlunosNestedInput
    pontos?: pontosUncheckedUpdateManyWithoutAlunosNestedInput
    atividades_concluidas?: atividades_concluidasUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type alunosCreateManyInput = {
    id_aluno?: number
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
  }

  export type alunosUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type alunosUncheckedUpdateManyInput = {
    id_aluno?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type professoresCreateInput = {
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
    turma?: turmasCreateNestedManyWithoutProfessoresInput
  }

  export type professoresUncheckedCreateInput = {
    id_prof?: number
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
    turma?: turmasUncheckedCreateNestedManyWithoutProfessoresInput
  }

  export type professoresUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
    turma?: turmasUpdateManyWithoutProfessoresNestedInput
  }

  export type professoresUncheckedUpdateInput = {
    id_prof?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
    turma?: turmasUncheckedUpdateManyWithoutProfessoresNestedInput
  }

  export type professoresCreateManyInput = {
    id_prof?: number
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
  }

  export type professoresUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type professoresUncheckedUpdateManyInput = {
    id_prof?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type atividadesCreateInput = {
    titulo: string
    descricao: string
    prazo: Date | string
    pontos_conclusao?: number
    turma: turmasCreateNestedOneWithoutAtividadesInput
    atividades_concluidas?: atividades_concluidasCreateNestedManyWithoutAtividadeInput
  }

  export type atividadesUncheckedCreateInput = {
    id_atividade?: number
    id_turma: number
    titulo: string
    descricao: string
    prazo: Date | string
    pontos_conclusao?: number
    atividades_concluidas?: atividades_concluidasUncheckedCreateNestedManyWithoutAtividadeInput
  }

  export type atividadesUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    pontos_conclusao?: IntFieldUpdateOperationsInput | number
    turma?: turmasUpdateOneRequiredWithoutAtividadesNestedInput
    atividades_concluidas?: atividades_concluidasUpdateManyWithoutAtividadeNestedInput
  }

  export type atividadesUncheckedUpdateInput = {
    id_atividade?: IntFieldUpdateOperationsInput | number
    id_turma?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    pontos_conclusao?: IntFieldUpdateOperationsInput | number
    atividades_concluidas?: atividades_concluidasUncheckedUpdateManyWithoutAtividadeNestedInput
  }

  export type atividadesCreateManyInput = {
    id_atividade?: number
    id_turma: number
    titulo: string
    descricao: string
    prazo: Date | string
    pontos_conclusao?: number
  }

  export type atividadesUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    pontos_conclusao?: IntFieldUpdateOperationsInput | number
  }

  export type atividadesUncheckedUpdateManyInput = {
    id_atividade?: IntFieldUpdateOperationsInput | number
    id_turma?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    pontos_conclusao?: IntFieldUpdateOperationsInput | number
  }

  export type atividades_concluidasCreateInput = {
    data_concluida: Date | string
    arquivo: string
    atividade: atividadesCreateNestedOneWithoutAtividades_concluidasInput
    aluno: alunosCreateNestedOneWithoutAtividades_concluidasInput
  }

  export type atividades_concluidasUncheckedCreateInput = {
    id_concluida?: number
    id_atividade: number
    id_aluno: number
    data_concluida: Date | string
    arquivo: string
  }

  export type atividades_concluidasUpdateInput = {
    data_concluida?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivo?: StringFieldUpdateOperationsInput | string
    atividade?: atividadesUpdateOneRequiredWithoutAtividades_concluidasNestedInput
    aluno?: alunosUpdateOneRequiredWithoutAtividades_concluidasNestedInput
  }

  export type atividades_concluidasUncheckedUpdateInput = {
    id_concluida?: IntFieldUpdateOperationsInput | number
    id_atividade?: IntFieldUpdateOperationsInput | number
    id_aluno?: IntFieldUpdateOperationsInput | number
    data_concluida?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivo?: StringFieldUpdateOperationsInput | string
  }

  export type atividades_concluidasCreateManyInput = {
    id_concluida?: number
    id_atividade: number
    id_aluno: number
    data_concluida: Date | string
    arquivo: string
  }

  export type atividades_concluidasUpdateManyMutationInput = {
    data_concluida?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivo?: StringFieldUpdateOperationsInput | string
  }

  export type atividades_concluidasUncheckedUpdateManyInput = {
    id_concluida?: IntFieldUpdateOperationsInput | number
    id_atividade?: IntFieldUpdateOperationsInput | number
    id_aluno?: IntFieldUpdateOperationsInput | number
    data_concluida?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivo?: StringFieldUpdateOperationsInput | string
  }

  export type turmasCreateInput = {
    nome: string
    codigo: string
    professores?: professoresCreateNestedManyWithoutTurmaInput
    alunos?: alunosCreateNestedManyWithoutTurmaInput
    atividades?: atividadesCreateNestedManyWithoutTurmaInput
    pontos?: pontosCreateNestedManyWithoutTurmaInput
    premios?: premiosCreateNestedManyWithoutTurmaInput
  }

  export type turmasUncheckedCreateInput = {
    id_turma?: number
    nome: string
    codigo: string
    professores?: professoresUncheckedCreateNestedManyWithoutTurmaInput
    alunos?: alunosUncheckedCreateNestedManyWithoutTurmaInput
    atividades?: atividadesUncheckedCreateNestedManyWithoutTurmaInput
    pontos?: pontosUncheckedCreateNestedManyWithoutTurmaInput
    premios?: premiosUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type turmasUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    professores?: professoresUpdateManyWithoutTurmaNestedInput
    alunos?: alunosUpdateManyWithoutTurmaNestedInput
    atividades?: atividadesUpdateManyWithoutTurmaNestedInput
    pontos?: pontosUpdateManyWithoutTurmaNestedInput
    premios?: premiosUpdateManyWithoutTurmaNestedInput
  }

  export type turmasUncheckedUpdateInput = {
    id_turma?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    professores?: professoresUncheckedUpdateManyWithoutTurmaNestedInput
    alunos?: alunosUncheckedUpdateManyWithoutTurmaNestedInput
    atividades?: atividadesUncheckedUpdateManyWithoutTurmaNestedInput
    pontos?: pontosUncheckedUpdateManyWithoutTurmaNestedInput
    premios?: premiosUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type turmasCreateManyInput = {
    id_turma?: number
    nome: string
    codigo: string
  }

  export type turmasUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
  }

  export type turmasUncheckedUpdateManyInput = {
    id_turma?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
  }

  export type premiosCreateInput = {
    descricao: string
    pontos_requeridos: number
    turma: turmasCreateNestedOneWithoutPremiosInput
  }

  export type premiosUncheckedCreateInput = {
    id_premio?: number
    id_turma: number
    descricao: string
    pontos_requeridos: number
  }

  export type premiosUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    pontos_requeridos?: FloatFieldUpdateOperationsInput | number
    turma?: turmasUpdateOneRequiredWithoutPremiosNestedInput
  }

  export type premiosUncheckedUpdateInput = {
    id_premio?: IntFieldUpdateOperationsInput | number
    id_turma?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pontos_requeridos?: FloatFieldUpdateOperationsInput | number
  }

  export type premiosCreateManyInput = {
    id_premio?: number
    id_turma: number
    descricao: string
    pontos_requeridos: number
  }

  export type premiosUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    pontos_requeridos?: FloatFieldUpdateOperationsInput | number
  }

  export type premiosUncheckedUpdateManyInput = {
    id_premio?: IntFieldUpdateOperationsInput | number
    id_turma?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pontos_requeridos?: FloatFieldUpdateOperationsInput | number
  }

  export type pontosCreateInput = {
    qtd?: number | null
    alunos: alunosCreateNestedOneWithoutPontosInput
    turma: turmasCreateNestedOneWithoutPontosInput
  }

  export type pontosUncheckedCreateInput = {
    id_ponto?: number
    id_aluno: number
    id_turma: number
    qtd?: number | null
  }

  export type pontosUpdateInput = {
    qtd?: NullableFloatFieldUpdateOperationsInput | number | null
    alunos?: alunosUpdateOneRequiredWithoutPontosNestedInput
    turma?: turmasUpdateOneRequiredWithoutPontosNestedInput
  }

  export type pontosUncheckedUpdateInput = {
    id_ponto?: IntFieldUpdateOperationsInput | number
    id_aluno?: IntFieldUpdateOperationsInput | number
    id_turma?: IntFieldUpdateOperationsInput | number
    qtd?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type pontosCreateManyInput = {
    id_ponto?: number
    id_aluno: number
    id_turma: number
    qtd?: number | null
  }

  export type pontosUpdateManyMutationInput = {
    qtd?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type pontosUncheckedUpdateManyInput = {
    id_ponto?: IntFieldUpdateOperationsInput | number
    id_aluno?: IntFieldUpdateOperationsInput | number
    id_turma?: IntFieldUpdateOperationsInput | number
    qtd?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type TurmasListRelationFilter = {
    every?: turmasWhereInput
    some?: turmasWhereInput
    none?: turmasWhereInput
  }

  export type PontosListRelationFilter = {
    every?: pontosWhereInput
    some?: pontosWhereInput
    none?: pontosWhereInput
  }

  export type Atividades_concluidasListRelationFilter = {
    every?: atividades_concluidasWhereInput
    some?: atividades_concluidasWhereInput
    none?: atividades_concluidasWhereInput
  }

  export type turmasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pontosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type atividades_concluidasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type alunosCountOrderByAggregateInput = {
    id_aluno?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel_de_acesso?: SortOrder
  }

  export type alunosAvgOrderByAggregateInput = {
    id_aluno?: SortOrder
  }

  export type alunosMaxOrderByAggregateInput = {
    id_aluno?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel_de_acesso?: SortOrder
  }

  export type alunosMinOrderByAggregateInput = {
    id_aluno?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel_de_acesso?: SortOrder
  }

  export type alunosSumOrderByAggregateInput = {
    id_aluno?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type professoresCountOrderByAggregateInput = {
    id_prof?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel_de_acesso?: SortOrder
  }

  export type professoresAvgOrderByAggregateInput = {
    id_prof?: SortOrder
  }

  export type professoresMaxOrderByAggregateInput = {
    id_prof?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel_de_acesso?: SortOrder
  }

  export type professoresMinOrderByAggregateInput = {
    id_prof?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel_de_acesso?: SortOrder
  }

  export type professoresSumOrderByAggregateInput = {
    id_prof?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type TurmasRelationFilter = {
    is?: turmasWhereInput
    isNot?: turmasWhereInput
  }

  export type atividadesCountOrderByAggregateInput = {
    id_atividade?: SortOrder
    id_turma?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    prazo?: SortOrder
    pontos_conclusao?: SortOrder
  }

  export type atividadesAvgOrderByAggregateInput = {
    id_atividade?: SortOrder
    id_turma?: SortOrder
    pontos_conclusao?: SortOrder
  }

  export type atividadesMaxOrderByAggregateInput = {
    id_atividade?: SortOrder
    id_turma?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    prazo?: SortOrder
    pontos_conclusao?: SortOrder
  }

  export type atividadesMinOrderByAggregateInput = {
    id_atividade?: SortOrder
    id_turma?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    prazo?: SortOrder
    pontos_conclusao?: SortOrder
  }

  export type atividadesSumOrderByAggregateInput = {
    id_atividade?: SortOrder
    id_turma?: SortOrder
    pontos_conclusao?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type AtividadesRelationFilter = {
    is?: atividadesWhereInput
    isNot?: atividadesWhereInput
  }

  export type AlunosRelationFilter = {
    is?: alunosWhereInput
    isNot?: alunosWhereInput
  }

  export type atividades_concluidasCountOrderByAggregateInput = {
    id_concluida?: SortOrder
    id_atividade?: SortOrder
    id_aluno?: SortOrder
    data_concluida?: SortOrder
    arquivo?: SortOrder
  }

  export type atividades_concluidasAvgOrderByAggregateInput = {
    id_concluida?: SortOrder
    id_atividade?: SortOrder
    id_aluno?: SortOrder
  }

  export type atividades_concluidasMaxOrderByAggregateInput = {
    id_concluida?: SortOrder
    id_atividade?: SortOrder
    id_aluno?: SortOrder
    data_concluida?: SortOrder
    arquivo?: SortOrder
  }

  export type atividades_concluidasMinOrderByAggregateInput = {
    id_concluida?: SortOrder
    id_atividade?: SortOrder
    id_aluno?: SortOrder
    data_concluida?: SortOrder
    arquivo?: SortOrder
  }

  export type atividades_concluidasSumOrderByAggregateInput = {
    id_concluida?: SortOrder
    id_atividade?: SortOrder
    id_aluno?: SortOrder
  }

  export type ProfessoresListRelationFilter = {
    every?: professoresWhereInput
    some?: professoresWhereInput
    none?: professoresWhereInput
  }

  export type AlunosListRelationFilter = {
    every?: alunosWhereInput
    some?: alunosWhereInput
    none?: alunosWhereInput
  }

  export type AtividadesListRelationFilter = {
    every?: atividadesWhereInput
    some?: atividadesWhereInput
    none?: atividadesWhereInput
  }

  export type PremiosListRelationFilter = {
    every?: premiosWhereInput
    some?: premiosWhereInput
    none?: premiosWhereInput
  }

  export type professoresOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type alunosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type atividadesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type premiosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type turmasCountOrderByAggregateInput = {
    id_turma?: SortOrder
    nome?: SortOrder
    codigo?: SortOrder
  }

  export type turmasAvgOrderByAggregateInput = {
    id_turma?: SortOrder
  }

  export type turmasMaxOrderByAggregateInput = {
    id_turma?: SortOrder
    nome?: SortOrder
    codigo?: SortOrder
  }

  export type turmasMinOrderByAggregateInput = {
    id_turma?: SortOrder
    nome?: SortOrder
    codigo?: SortOrder
  }

  export type turmasSumOrderByAggregateInput = {
    id_turma?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type premiosCountOrderByAggregateInput = {
    id_premio?: SortOrder
    id_turma?: SortOrder
    descricao?: SortOrder
    pontos_requeridos?: SortOrder
  }

  export type premiosAvgOrderByAggregateInput = {
    id_premio?: SortOrder
    id_turma?: SortOrder
    pontos_requeridos?: SortOrder
  }

  export type premiosMaxOrderByAggregateInput = {
    id_premio?: SortOrder
    id_turma?: SortOrder
    descricao?: SortOrder
    pontos_requeridos?: SortOrder
  }

  export type premiosMinOrderByAggregateInput = {
    id_premio?: SortOrder
    id_turma?: SortOrder
    descricao?: SortOrder
    pontos_requeridos?: SortOrder
  }

  export type premiosSumOrderByAggregateInput = {
    id_premio?: SortOrder
    id_turma?: SortOrder
    pontos_requeridos?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type pontosCountOrderByAggregateInput = {
    id_ponto?: SortOrder
    id_aluno?: SortOrder
    id_turma?: SortOrder
    qtd?: SortOrder
  }

  export type pontosAvgOrderByAggregateInput = {
    id_ponto?: SortOrder
    id_aluno?: SortOrder
    id_turma?: SortOrder
    qtd?: SortOrder
  }

  export type pontosMaxOrderByAggregateInput = {
    id_ponto?: SortOrder
    id_aluno?: SortOrder
    id_turma?: SortOrder
    qtd?: SortOrder
  }

  export type pontosMinOrderByAggregateInput = {
    id_ponto?: SortOrder
    id_aluno?: SortOrder
    id_turma?: SortOrder
    qtd?: SortOrder
  }

  export type pontosSumOrderByAggregateInput = {
    id_ponto?: SortOrder
    id_aluno?: SortOrder
    id_turma?: SortOrder
    qtd?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type turmasCreateNestedManyWithoutAlunosInput = {
    create?: XOR<Enumerable<turmasCreateWithoutAlunosInput>, Enumerable<turmasUncheckedCreateWithoutAlunosInput>>
    connectOrCreate?: Enumerable<turmasCreateOrConnectWithoutAlunosInput>
    connect?: Enumerable<turmasWhereUniqueInput>
  }

  export type pontosCreateNestedManyWithoutAlunosInput = {
    create?: XOR<Enumerable<pontosCreateWithoutAlunosInput>, Enumerable<pontosUncheckedCreateWithoutAlunosInput>>
    connectOrCreate?: Enumerable<pontosCreateOrConnectWithoutAlunosInput>
    createMany?: pontosCreateManyAlunosInputEnvelope
    connect?: Enumerable<pontosWhereUniqueInput>
  }

  export type atividades_concluidasCreateNestedManyWithoutAlunoInput = {
    create?: XOR<Enumerable<atividades_concluidasCreateWithoutAlunoInput>, Enumerable<atividades_concluidasUncheckedCreateWithoutAlunoInput>>
    connectOrCreate?: Enumerable<atividades_concluidasCreateOrConnectWithoutAlunoInput>
    createMany?: atividades_concluidasCreateManyAlunoInputEnvelope
    connect?: Enumerable<atividades_concluidasWhereUniqueInput>
  }

  export type turmasUncheckedCreateNestedManyWithoutAlunosInput = {
    create?: XOR<Enumerable<turmasCreateWithoutAlunosInput>, Enumerable<turmasUncheckedCreateWithoutAlunosInput>>
    connectOrCreate?: Enumerable<turmasCreateOrConnectWithoutAlunosInput>
    connect?: Enumerable<turmasWhereUniqueInput>
  }

  export type pontosUncheckedCreateNestedManyWithoutAlunosInput = {
    create?: XOR<Enumerable<pontosCreateWithoutAlunosInput>, Enumerable<pontosUncheckedCreateWithoutAlunosInput>>
    connectOrCreate?: Enumerable<pontosCreateOrConnectWithoutAlunosInput>
    createMany?: pontosCreateManyAlunosInputEnvelope
    connect?: Enumerable<pontosWhereUniqueInput>
  }

  export type atividades_concluidasUncheckedCreateNestedManyWithoutAlunoInput = {
    create?: XOR<Enumerable<atividades_concluidasCreateWithoutAlunoInput>, Enumerable<atividades_concluidasUncheckedCreateWithoutAlunoInput>>
    connectOrCreate?: Enumerable<atividades_concluidasCreateOrConnectWithoutAlunoInput>
    createMany?: atividades_concluidasCreateManyAlunoInputEnvelope
    connect?: Enumerable<atividades_concluidasWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type turmasUpdateManyWithoutAlunosNestedInput = {
    create?: XOR<Enumerable<turmasCreateWithoutAlunosInput>, Enumerable<turmasUncheckedCreateWithoutAlunosInput>>
    connectOrCreate?: Enumerable<turmasCreateOrConnectWithoutAlunosInput>
    upsert?: Enumerable<turmasUpsertWithWhereUniqueWithoutAlunosInput>
    set?: Enumerable<turmasWhereUniqueInput>
    disconnect?: Enumerable<turmasWhereUniqueInput>
    delete?: Enumerable<turmasWhereUniqueInput>
    connect?: Enumerable<turmasWhereUniqueInput>
    update?: Enumerable<turmasUpdateWithWhereUniqueWithoutAlunosInput>
    updateMany?: Enumerable<turmasUpdateManyWithWhereWithoutAlunosInput>
    deleteMany?: Enumerable<turmasScalarWhereInput>
  }

  export type pontosUpdateManyWithoutAlunosNestedInput = {
    create?: XOR<Enumerable<pontosCreateWithoutAlunosInput>, Enumerable<pontosUncheckedCreateWithoutAlunosInput>>
    connectOrCreate?: Enumerable<pontosCreateOrConnectWithoutAlunosInput>
    upsert?: Enumerable<pontosUpsertWithWhereUniqueWithoutAlunosInput>
    createMany?: pontosCreateManyAlunosInputEnvelope
    set?: Enumerable<pontosWhereUniqueInput>
    disconnect?: Enumerable<pontosWhereUniqueInput>
    delete?: Enumerable<pontosWhereUniqueInput>
    connect?: Enumerable<pontosWhereUniqueInput>
    update?: Enumerable<pontosUpdateWithWhereUniqueWithoutAlunosInput>
    updateMany?: Enumerable<pontosUpdateManyWithWhereWithoutAlunosInput>
    deleteMany?: Enumerable<pontosScalarWhereInput>
  }

  export type atividades_concluidasUpdateManyWithoutAlunoNestedInput = {
    create?: XOR<Enumerable<atividades_concluidasCreateWithoutAlunoInput>, Enumerable<atividades_concluidasUncheckedCreateWithoutAlunoInput>>
    connectOrCreate?: Enumerable<atividades_concluidasCreateOrConnectWithoutAlunoInput>
    upsert?: Enumerable<atividades_concluidasUpsertWithWhereUniqueWithoutAlunoInput>
    createMany?: atividades_concluidasCreateManyAlunoInputEnvelope
    set?: Enumerable<atividades_concluidasWhereUniqueInput>
    disconnect?: Enumerable<atividades_concluidasWhereUniqueInput>
    delete?: Enumerable<atividades_concluidasWhereUniqueInput>
    connect?: Enumerable<atividades_concluidasWhereUniqueInput>
    update?: Enumerable<atividades_concluidasUpdateWithWhereUniqueWithoutAlunoInput>
    updateMany?: Enumerable<atividades_concluidasUpdateManyWithWhereWithoutAlunoInput>
    deleteMany?: Enumerable<atividades_concluidasScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type turmasUncheckedUpdateManyWithoutAlunosNestedInput = {
    create?: XOR<Enumerable<turmasCreateWithoutAlunosInput>, Enumerable<turmasUncheckedCreateWithoutAlunosInput>>
    connectOrCreate?: Enumerable<turmasCreateOrConnectWithoutAlunosInput>
    upsert?: Enumerable<turmasUpsertWithWhereUniqueWithoutAlunosInput>
    set?: Enumerable<turmasWhereUniqueInput>
    disconnect?: Enumerable<turmasWhereUniqueInput>
    delete?: Enumerable<turmasWhereUniqueInput>
    connect?: Enumerable<turmasWhereUniqueInput>
    update?: Enumerable<turmasUpdateWithWhereUniqueWithoutAlunosInput>
    updateMany?: Enumerable<turmasUpdateManyWithWhereWithoutAlunosInput>
    deleteMany?: Enumerable<turmasScalarWhereInput>
  }

  export type pontosUncheckedUpdateManyWithoutAlunosNestedInput = {
    create?: XOR<Enumerable<pontosCreateWithoutAlunosInput>, Enumerable<pontosUncheckedCreateWithoutAlunosInput>>
    connectOrCreate?: Enumerable<pontosCreateOrConnectWithoutAlunosInput>
    upsert?: Enumerable<pontosUpsertWithWhereUniqueWithoutAlunosInput>
    createMany?: pontosCreateManyAlunosInputEnvelope
    set?: Enumerable<pontosWhereUniqueInput>
    disconnect?: Enumerable<pontosWhereUniqueInput>
    delete?: Enumerable<pontosWhereUniqueInput>
    connect?: Enumerable<pontosWhereUniqueInput>
    update?: Enumerable<pontosUpdateWithWhereUniqueWithoutAlunosInput>
    updateMany?: Enumerable<pontosUpdateManyWithWhereWithoutAlunosInput>
    deleteMany?: Enumerable<pontosScalarWhereInput>
  }

  export type atividades_concluidasUncheckedUpdateManyWithoutAlunoNestedInput = {
    create?: XOR<Enumerable<atividades_concluidasCreateWithoutAlunoInput>, Enumerable<atividades_concluidasUncheckedCreateWithoutAlunoInput>>
    connectOrCreate?: Enumerable<atividades_concluidasCreateOrConnectWithoutAlunoInput>
    upsert?: Enumerable<atividades_concluidasUpsertWithWhereUniqueWithoutAlunoInput>
    createMany?: atividades_concluidasCreateManyAlunoInputEnvelope
    set?: Enumerable<atividades_concluidasWhereUniqueInput>
    disconnect?: Enumerable<atividades_concluidasWhereUniqueInput>
    delete?: Enumerable<atividades_concluidasWhereUniqueInput>
    connect?: Enumerable<atividades_concluidasWhereUniqueInput>
    update?: Enumerable<atividades_concluidasUpdateWithWhereUniqueWithoutAlunoInput>
    updateMany?: Enumerable<atividades_concluidasUpdateManyWithWhereWithoutAlunoInput>
    deleteMany?: Enumerable<atividades_concluidasScalarWhereInput>
  }

  export type turmasCreateNestedManyWithoutProfessoresInput = {
    create?: XOR<Enumerable<turmasCreateWithoutProfessoresInput>, Enumerable<turmasUncheckedCreateWithoutProfessoresInput>>
    connectOrCreate?: Enumerable<turmasCreateOrConnectWithoutProfessoresInput>
    connect?: Enumerable<turmasWhereUniqueInput>
  }

  export type turmasUncheckedCreateNestedManyWithoutProfessoresInput = {
    create?: XOR<Enumerable<turmasCreateWithoutProfessoresInput>, Enumerable<turmasUncheckedCreateWithoutProfessoresInput>>
    connectOrCreate?: Enumerable<turmasCreateOrConnectWithoutProfessoresInput>
    connect?: Enumerable<turmasWhereUniqueInput>
  }

  export type turmasUpdateManyWithoutProfessoresNestedInput = {
    create?: XOR<Enumerable<turmasCreateWithoutProfessoresInput>, Enumerable<turmasUncheckedCreateWithoutProfessoresInput>>
    connectOrCreate?: Enumerable<turmasCreateOrConnectWithoutProfessoresInput>
    upsert?: Enumerable<turmasUpsertWithWhereUniqueWithoutProfessoresInput>
    set?: Enumerable<turmasWhereUniqueInput>
    disconnect?: Enumerable<turmasWhereUniqueInput>
    delete?: Enumerable<turmasWhereUniqueInput>
    connect?: Enumerable<turmasWhereUniqueInput>
    update?: Enumerable<turmasUpdateWithWhereUniqueWithoutProfessoresInput>
    updateMany?: Enumerable<turmasUpdateManyWithWhereWithoutProfessoresInput>
    deleteMany?: Enumerable<turmasScalarWhereInput>
  }

  export type turmasUncheckedUpdateManyWithoutProfessoresNestedInput = {
    create?: XOR<Enumerable<turmasCreateWithoutProfessoresInput>, Enumerable<turmasUncheckedCreateWithoutProfessoresInput>>
    connectOrCreate?: Enumerable<turmasCreateOrConnectWithoutProfessoresInput>
    upsert?: Enumerable<turmasUpsertWithWhereUniqueWithoutProfessoresInput>
    set?: Enumerable<turmasWhereUniqueInput>
    disconnect?: Enumerable<turmasWhereUniqueInput>
    delete?: Enumerable<turmasWhereUniqueInput>
    connect?: Enumerable<turmasWhereUniqueInput>
    update?: Enumerable<turmasUpdateWithWhereUniqueWithoutProfessoresInput>
    updateMany?: Enumerable<turmasUpdateManyWithWhereWithoutProfessoresInput>
    deleteMany?: Enumerable<turmasScalarWhereInput>
  }

  export type turmasCreateNestedOneWithoutAtividadesInput = {
    create?: XOR<turmasCreateWithoutAtividadesInput, turmasUncheckedCreateWithoutAtividadesInput>
    connectOrCreate?: turmasCreateOrConnectWithoutAtividadesInput
    connect?: turmasWhereUniqueInput
  }

  export type atividades_concluidasCreateNestedManyWithoutAtividadeInput = {
    create?: XOR<Enumerable<atividades_concluidasCreateWithoutAtividadeInput>, Enumerable<atividades_concluidasUncheckedCreateWithoutAtividadeInput>>
    connectOrCreate?: Enumerable<atividades_concluidasCreateOrConnectWithoutAtividadeInput>
    createMany?: atividades_concluidasCreateManyAtividadeInputEnvelope
    connect?: Enumerable<atividades_concluidasWhereUniqueInput>
  }

  export type atividades_concluidasUncheckedCreateNestedManyWithoutAtividadeInput = {
    create?: XOR<Enumerable<atividades_concluidasCreateWithoutAtividadeInput>, Enumerable<atividades_concluidasUncheckedCreateWithoutAtividadeInput>>
    connectOrCreate?: Enumerable<atividades_concluidasCreateOrConnectWithoutAtividadeInput>
    createMany?: atividades_concluidasCreateManyAtividadeInputEnvelope
    connect?: Enumerable<atividades_concluidasWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type turmasUpdateOneRequiredWithoutAtividadesNestedInput = {
    create?: XOR<turmasCreateWithoutAtividadesInput, turmasUncheckedCreateWithoutAtividadesInput>
    connectOrCreate?: turmasCreateOrConnectWithoutAtividadesInput
    upsert?: turmasUpsertWithoutAtividadesInput
    connect?: turmasWhereUniqueInput
    update?: XOR<turmasUpdateWithoutAtividadesInput, turmasUncheckedUpdateWithoutAtividadesInput>
  }

  export type atividades_concluidasUpdateManyWithoutAtividadeNestedInput = {
    create?: XOR<Enumerable<atividades_concluidasCreateWithoutAtividadeInput>, Enumerable<atividades_concluidasUncheckedCreateWithoutAtividadeInput>>
    connectOrCreate?: Enumerable<atividades_concluidasCreateOrConnectWithoutAtividadeInput>
    upsert?: Enumerable<atividades_concluidasUpsertWithWhereUniqueWithoutAtividadeInput>
    createMany?: atividades_concluidasCreateManyAtividadeInputEnvelope
    set?: Enumerable<atividades_concluidasWhereUniqueInput>
    disconnect?: Enumerable<atividades_concluidasWhereUniqueInput>
    delete?: Enumerable<atividades_concluidasWhereUniqueInput>
    connect?: Enumerable<atividades_concluidasWhereUniqueInput>
    update?: Enumerable<atividades_concluidasUpdateWithWhereUniqueWithoutAtividadeInput>
    updateMany?: Enumerable<atividades_concluidasUpdateManyWithWhereWithoutAtividadeInput>
    deleteMany?: Enumerable<atividades_concluidasScalarWhereInput>
  }

  export type atividades_concluidasUncheckedUpdateManyWithoutAtividadeNestedInput = {
    create?: XOR<Enumerable<atividades_concluidasCreateWithoutAtividadeInput>, Enumerable<atividades_concluidasUncheckedCreateWithoutAtividadeInput>>
    connectOrCreate?: Enumerable<atividades_concluidasCreateOrConnectWithoutAtividadeInput>
    upsert?: Enumerable<atividades_concluidasUpsertWithWhereUniqueWithoutAtividadeInput>
    createMany?: atividades_concluidasCreateManyAtividadeInputEnvelope
    set?: Enumerable<atividades_concluidasWhereUniqueInput>
    disconnect?: Enumerable<atividades_concluidasWhereUniqueInput>
    delete?: Enumerable<atividades_concluidasWhereUniqueInput>
    connect?: Enumerable<atividades_concluidasWhereUniqueInput>
    update?: Enumerable<atividades_concluidasUpdateWithWhereUniqueWithoutAtividadeInput>
    updateMany?: Enumerable<atividades_concluidasUpdateManyWithWhereWithoutAtividadeInput>
    deleteMany?: Enumerable<atividades_concluidasScalarWhereInput>
  }

  export type atividadesCreateNestedOneWithoutAtividades_concluidasInput = {
    create?: XOR<atividadesCreateWithoutAtividades_concluidasInput, atividadesUncheckedCreateWithoutAtividades_concluidasInput>
    connectOrCreate?: atividadesCreateOrConnectWithoutAtividades_concluidasInput
    connect?: atividadesWhereUniqueInput
  }

  export type alunosCreateNestedOneWithoutAtividades_concluidasInput = {
    create?: XOR<alunosCreateWithoutAtividades_concluidasInput, alunosUncheckedCreateWithoutAtividades_concluidasInput>
    connectOrCreate?: alunosCreateOrConnectWithoutAtividades_concluidasInput
    connect?: alunosWhereUniqueInput
  }

  export type atividadesUpdateOneRequiredWithoutAtividades_concluidasNestedInput = {
    create?: XOR<atividadesCreateWithoutAtividades_concluidasInput, atividadesUncheckedCreateWithoutAtividades_concluidasInput>
    connectOrCreate?: atividadesCreateOrConnectWithoutAtividades_concluidasInput
    upsert?: atividadesUpsertWithoutAtividades_concluidasInput
    connect?: atividadesWhereUniqueInput
    update?: XOR<atividadesUpdateWithoutAtividades_concluidasInput, atividadesUncheckedUpdateWithoutAtividades_concluidasInput>
  }

  export type alunosUpdateOneRequiredWithoutAtividades_concluidasNestedInput = {
    create?: XOR<alunosCreateWithoutAtividades_concluidasInput, alunosUncheckedCreateWithoutAtividades_concluidasInput>
    connectOrCreate?: alunosCreateOrConnectWithoutAtividades_concluidasInput
    upsert?: alunosUpsertWithoutAtividades_concluidasInput
    connect?: alunosWhereUniqueInput
    update?: XOR<alunosUpdateWithoutAtividades_concluidasInput, alunosUncheckedUpdateWithoutAtividades_concluidasInput>
  }

  export type professoresCreateNestedManyWithoutTurmaInput = {
    create?: XOR<Enumerable<professoresCreateWithoutTurmaInput>, Enumerable<professoresUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<professoresCreateOrConnectWithoutTurmaInput>
    connect?: Enumerable<professoresWhereUniqueInput>
  }

  export type alunosCreateNestedManyWithoutTurmaInput = {
    create?: XOR<Enumerable<alunosCreateWithoutTurmaInput>, Enumerable<alunosUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<alunosCreateOrConnectWithoutTurmaInput>
    connect?: Enumerable<alunosWhereUniqueInput>
  }

  export type atividadesCreateNestedManyWithoutTurmaInput = {
    create?: XOR<Enumerable<atividadesCreateWithoutTurmaInput>, Enumerable<atividadesUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<atividadesCreateOrConnectWithoutTurmaInput>
    createMany?: atividadesCreateManyTurmaInputEnvelope
    connect?: Enumerable<atividadesWhereUniqueInput>
  }

  export type pontosCreateNestedManyWithoutTurmaInput = {
    create?: XOR<Enumerable<pontosCreateWithoutTurmaInput>, Enumerable<pontosUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<pontosCreateOrConnectWithoutTurmaInput>
    createMany?: pontosCreateManyTurmaInputEnvelope
    connect?: Enumerable<pontosWhereUniqueInput>
  }

  export type premiosCreateNestedManyWithoutTurmaInput = {
    create?: XOR<Enumerable<premiosCreateWithoutTurmaInput>, Enumerable<premiosUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<premiosCreateOrConnectWithoutTurmaInput>
    createMany?: premiosCreateManyTurmaInputEnvelope
    connect?: Enumerable<premiosWhereUniqueInput>
  }

  export type professoresUncheckedCreateNestedManyWithoutTurmaInput = {
    create?: XOR<Enumerable<professoresCreateWithoutTurmaInput>, Enumerable<professoresUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<professoresCreateOrConnectWithoutTurmaInput>
    connect?: Enumerable<professoresWhereUniqueInput>
  }

  export type alunosUncheckedCreateNestedManyWithoutTurmaInput = {
    create?: XOR<Enumerable<alunosCreateWithoutTurmaInput>, Enumerable<alunosUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<alunosCreateOrConnectWithoutTurmaInput>
    connect?: Enumerable<alunosWhereUniqueInput>
  }

  export type atividadesUncheckedCreateNestedManyWithoutTurmaInput = {
    create?: XOR<Enumerable<atividadesCreateWithoutTurmaInput>, Enumerable<atividadesUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<atividadesCreateOrConnectWithoutTurmaInput>
    createMany?: atividadesCreateManyTurmaInputEnvelope
    connect?: Enumerable<atividadesWhereUniqueInput>
  }

  export type pontosUncheckedCreateNestedManyWithoutTurmaInput = {
    create?: XOR<Enumerable<pontosCreateWithoutTurmaInput>, Enumerable<pontosUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<pontosCreateOrConnectWithoutTurmaInput>
    createMany?: pontosCreateManyTurmaInputEnvelope
    connect?: Enumerable<pontosWhereUniqueInput>
  }

  export type premiosUncheckedCreateNestedManyWithoutTurmaInput = {
    create?: XOR<Enumerable<premiosCreateWithoutTurmaInput>, Enumerable<premiosUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<premiosCreateOrConnectWithoutTurmaInput>
    createMany?: premiosCreateManyTurmaInputEnvelope
    connect?: Enumerable<premiosWhereUniqueInput>
  }

  export type professoresUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<Enumerable<professoresCreateWithoutTurmaInput>, Enumerable<professoresUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<professoresCreateOrConnectWithoutTurmaInput>
    upsert?: Enumerable<professoresUpsertWithWhereUniqueWithoutTurmaInput>
    set?: Enumerable<professoresWhereUniqueInput>
    disconnect?: Enumerable<professoresWhereUniqueInput>
    delete?: Enumerable<professoresWhereUniqueInput>
    connect?: Enumerable<professoresWhereUniqueInput>
    update?: Enumerable<professoresUpdateWithWhereUniqueWithoutTurmaInput>
    updateMany?: Enumerable<professoresUpdateManyWithWhereWithoutTurmaInput>
    deleteMany?: Enumerable<professoresScalarWhereInput>
  }

  export type alunosUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<Enumerable<alunosCreateWithoutTurmaInput>, Enumerable<alunosUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<alunosCreateOrConnectWithoutTurmaInput>
    upsert?: Enumerable<alunosUpsertWithWhereUniqueWithoutTurmaInput>
    set?: Enumerable<alunosWhereUniqueInput>
    disconnect?: Enumerable<alunosWhereUniqueInput>
    delete?: Enumerable<alunosWhereUniqueInput>
    connect?: Enumerable<alunosWhereUniqueInput>
    update?: Enumerable<alunosUpdateWithWhereUniqueWithoutTurmaInput>
    updateMany?: Enumerable<alunosUpdateManyWithWhereWithoutTurmaInput>
    deleteMany?: Enumerable<alunosScalarWhereInput>
  }

  export type atividadesUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<Enumerable<atividadesCreateWithoutTurmaInput>, Enumerable<atividadesUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<atividadesCreateOrConnectWithoutTurmaInput>
    upsert?: Enumerable<atividadesUpsertWithWhereUniqueWithoutTurmaInput>
    createMany?: atividadesCreateManyTurmaInputEnvelope
    set?: Enumerable<atividadesWhereUniqueInput>
    disconnect?: Enumerable<atividadesWhereUniqueInput>
    delete?: Enumerable<atividadesWhereUniqueInput>
    connect?: Enumerable<atividadesWhereUniqueInput>
    update?: Enumerable<atividadesUpdateWithWhereUniqueWithoutTurmaInput>
    updateMany?: Enumerable<atividadesUpdateManyWithWhereWithoutTurmaInput>
    deleteMany?: Enumerable<atividadesScalarWhereInput>
  }

  export type pontosUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<Enumerable<pontosCreateWithoutTurmaInput>, Enumerable<pontosUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<pontosCreateOrConnectWithoutTurmaInput>
    upsert?: Enumerable<pontosUpsertWithWhereUniqueWithoutTurmaInput>
    createMany?: pontosCreateManyTurmaInputEnvelope
    set?: Enumerable<pontosWhereUniqueInput>
    disconnect?: Enumerable<pontosWhereUniqueInput>
    delete?: Enumerable<pontosWhereUniqueInput>
    connect?: Enumerable<pontosWhereUniqueInput>
    update?: Enumerable<pontosUpdateWithWhereUniqueWithoutTurmaInput>
    updateMany?: Enumerable<pontosUpdateManyWithWhereWithoutTurmaInput>
    deleteMany?: Enumerable<pontosScalarWhereInput>
  }

  export type premiosUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<Enumerable<premiosCreateWithoutTurmaInput>, Enumerable<premiosUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<premiosCreateOrConnectWithoutTurmaInput>
    upsert?: Enumerable<premiosUpsertWithWhereUniqueWithoutTurmaInput>
    createMany?: premiosCreateManyTurmaInputEnvelope
    set?: Enumerable<premiosWhereUniqueInput>
    disconnect?: Enumerable<premiosWhereUniqueInput>
    delete?: Enumerable<premiosWhereUniqueInput>
    connect?: Enumerable<premiosWhereUniqueInput>
    update?: Enumerable<premiosUpdateWithWhereUniqueWithoutTurmaInput>
    updateMany?: Enumerable<premiosUpdateManyWithWhereWithoutTurmaInput>
    deleteMany?: Enumerable<premiosScalarWhereInput>
  }

  export type professoresUncheckedUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<Enumerable<professoresCreateWithoutTurmaInput>, Enumerable<professoresUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<professoresCreateOrConnectWithoutTurmaInput>
    upsert?: Enumerable<professoresUpsertWithWhereUniqueWithoutTurmaInput>
    set?: Enumerable<professoresWhereUniqueInput>
    disconnect?: Enumerable<professoresWhereUniqueInput>
    delete?: Enumerable<professoresWhereUniqueInput>
    connect?: Enumerable<professoresWhereUniqueInput>
    update?: Enumerable<professoresUpdateWithWhereUniqueWithoutTurmaInput>
    updateMany?: Enumerable<professoresUpdateManyWithWhereWithoutTurmaInput>
    deleteMany?: Enumerable<professoresScalarWhereInput>
  }

  export type alunosUncheckedUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<Enumerable<alunosCreateWithoutTurmaInput>, Enumerable<alunosUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<alunosCreateOrConnectWithoutTurmaInput>
    upsert?: Enumerable<alunosUpsertWithWhereUniqueWithoutTurmaInput>
    set?: Enumerable<alunosWhereUniqueInput>
    disconnect?: Enumerable<alunosWhereUniqueInput>
    delete?: Enumerable<alunosWhereUniqueInput>
    connect?: Enumerable<alunosWhereUniqueInput>
    update?: Enumerable<alunosUpdateWithWhereUniqueWithoutTurmaInput>
    updateMany?: Enumerable<alunosUpdateManyWithWhereWithoutTurmaInput>
    deleteMany?: Enumerable<alunosScalarWhereInput>
  }

  export type atividadesUncheckedUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<Enumerable<atividadesCreateWithoutTurmaInput>, Enumerable<atividadesUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<atividadesCreateOrConnectWithoutTurmaInput>
    upsert?: Enumerable<atividadesUpsertWithWhereUniqueWithoutTurmaInput>
    createMany?: atividadesCreateManyTurmaInputEnvelope
    set?: Enumerable<atividadesWhereUniqueInput>
    disconnect?: Enumerable<atividadesWhereUniqueInput>
    delete?: Enumerable<atividadesWhereUniqueInput>
    connect?: Enumerable<atividadesWhereUniqueInput>
    update?: Enumerable<atividadesUpdateWithWhereUniqueWithoutTurmaInput>
    updateMany?: Enumerable<atividadesUpdateManyWithWhereWithoutTurmaInput>
    deleteMany?: Enumerable<atividadesScalarWhereInput>
  }

  export type pontosUncheckedUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<Enumerable<pontosCreateWithoutTurmaInput>, Enumerable<pontosUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<pontosCreateOrConnectWithoutTurmaInput>
    upsert?: Enumerable<pontosUpsertWithWhereUniqueWithoutTurmaInput>
    createMany?: pontosCreateManyTurmaInputEnvelope
    set?: Enumerable<pontosWhereUniqueInput>
    disconnect?: Enumerable<pontosWhereUniqueInput>
    delete?: Enumerable<pontosWhereUniqueInput>
    connect?: Enumerable<pontosWhereUniqueInput>
    update?: Enumerable<pontosUpdateWithWhereUniqueWithoutTurmaInput>
    updateMany?: Enumerable<pontosUpdateManyWithWhereWithoutTurmaInput>
    deleteMany?: Enumerable<pontosScalarWhereInput>
  }

  export type premiosUncheckedUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<Enumerable<premiosCreateWithoutTurmaInput>, Enumerable<premiosUncheckedCreateWithoutTurmaInput>>
    connectOrCreate?: Enumerable<premiosCreateOrConnectWithoutTurmaInput>
    upsert?: Enumerable<premiosUpsertWithWhereUniqueWithoutTurmaInput>
    createMany?: premiosCreateManyTurmaInputEnvelope
    set?: Enumerable<premiosWhereUniqueInput>
    disconnect?: Enumerable<premiosWhereUniqueInput>
    delete?: Enumerable<premiosWhereUniqueInput>
    connect?: Enumerable<premiosWhereUniqueInput>
    update?: Enumerable<premiosUpdateWithWhereUniqueWithoutTurmaInput>
    updateMany?: Enumerable<premiosUpdateManyWithWhereWithoutTurmaInput>
    deleteMany?: Enumerable<premiosScalarWhereInput>
  }

  export type turmasCreateNestedOneWithoutPremiosInput = {
    create?: XOR<turmasCreateWithoutPremiosInput, turmasUncheckedCreateWithoutPremiosInput>
    connectOrCreate?: turmasCreateOrConnectWithoutPremiosInput
    connect?: turmasWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type turmasUpdateOneRequiredWithoutPremiosNestedInput = {
    create?: XOR<turmasCreateWithoutPremiosInput, turmasUncheckedCreateWithoutPremiosInput>
    connectOrCreate?: turmasCreateOrConnectWithoutPremiosInput
    upsert?: turmasUpsertWithoutPremiosInput
    connect?: turmasWhereUniqueInput
    update?: XOR<turmasUpdateWithoutPremiosInput, turmasUncheckedUpdateWithoutPremiosInput>
  }

  export type alunosCreateNestedOneWithoutPontosInput = {
    create?: XOR<alunosCreateWithoutPontosInput, alunosUncheckedCreateWithoutPontosInput>
    connectOrCreate?: alunosCreateOrConnectWithoutPontosInput
    connect?: alunosWhereUniqueInput
  }

  export type turmasCreateNestedOneWithoutPontosInput = {
    create?: XOR<turmasCreateWithoutPontosInput, turmasUncheckedCreateWithoutPontosInput>
    connectOrCreate?: turmasCreateOrConnectWithoutPontosInput
    connect?: turmasWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type alunosUpdateOneRequiredWithoutPontosNestedInput = {
    create?: XOR<alunosCreateWithoutPontosInput, alunosUncheckedCreateWithoutPontosInput>
    connectOrCreate?: alunosCreateOrConnectWithoutPontosInput
    upsert?: alunosUpsertWithoutPontosInput
    connect?: alunosWhereUniqueInput
    update?: XOR<alunosUpdateWithoutPontosInput, alunosUncheckedUpdateWithoutPontosInput>
  }

  export type turmasUpdateOneRequiredWithoutPontosNestedInput = {
    create?: XOR<turmasCreateWithoutPontosInput, turmasUncheckedCreateWithoutPontosInput>
    connectOrCreate?: turmasCreateOrConnectWithoutPontosInput
    upsert?: turmasUpsertWithoutPontosInput
    connect?: turmasWhereUniqueInput
    update?: XOR<turmasUpdateWithoutPontosInput, turmasUncheckedUpdateWithoutPontosInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type turmasCreateWithoutAlunosInput = {
    nome: string
    codigo: string
    professores?: professoresCreateNestedManyWithoutTurmaInput
    atividades?: atividadesCreateNestedManyWithoutTurmaInput
    pontos?: pontosCreateNestedManyWithoutTurmaInput
    premios?: premiosCreateNestedManyWithoutTurmaInput
  }

  export type turmasUncheckedCreateWithoutAlunosInput = {
    id_turma?: number
    nome: string
    codigo: string
    professores?: professoresUncheckedCreateNestedManyWithoutTurmaInput
    atividades?: atividadesUncheckedCreateNestedManyWithoutTurmaInput
    pontos?: pontosUncheckedCreateNestedManyWithoutTurmaInput
    premios?: premiosUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type turmasCreateOrConnectWithoutAlunosInput = {
    where: turmasWhereUniqueInput
    create: XOR<turmasCreateWithoutAlunosInput, turmasUncheckedCreateWithoutAlunosInput>
  }

  export type pontosCreateWithoutAlunosInput = {
    qtd?: number | null
    turma: turmasCreateNestedOneWithoutPontosInput
  }

  export type pontosUncheckedCreateWithoutAlunosInput = {
    id_ponto?: number
    id_turma: number
    qtd?: number | null
  }

  export type pontosCreateOrConnectWithoutAlunosInput = {
    where: pontosWhereUniqueInput
    create: XOR<pontosCreateWithoutAlunosInput, pontosUncheckedCreateWithoutAlunosInput>
  }

  export type pontosCreateManyAlunosInputEnvelope = {
    data: Enumerable<pontosCreateManyAlunosInput>
    skipDuplicates?: boolean
  }

  export type atividades_concluidasCreateWithoutAlunoInput = {
    data_concluida: Date | string
    arquivo: string
    atividade: atividadesCreateNestedOneWithoutAtividades_concluidasInput
  }

  export type atividades_concluidasUncheckedCreateWithoutAlunoInput = {
    id_concluida?: number
    id_atividade: number
    data_concluida: Date | string
    arquivo: string
  }

  export type atividades_concluidasCreateOrConnectWithoutAlunoInput = {
    where: atividades_concluidasWhereUniqueInput
    create: XOR<atividades_concluidasCreateWithoutAlunoInput, atividades_concluidasUncheckedCreateWithoutAlunoInput>
  }

  export type atividades_concluidasCreateManyAlunoInputEnvelope = {
    data: Enumerable<atividades_concluidasCreateManyAlunoInput>
    skipDuplicates?: boolean
  }

  export type turmasUpsertWithWhereUniqueWithoutAlunosInput = {
    where: turmasWhereUniqueInput
    update: XOR<turmasUpdateWithoutAlunosInput, turmasUncheckedUpdateWithoutAlunosInput>
    create: XOR<turmasCreateWithoutAlunosInput, turmasUncheckedCreateWithoutAlunosInput>
  }

  export type turmasUpdateWithWhereUniqueWithoutAlunosInput = {
    where: turmasWhereUniqueInput
    data: XOR<turmasUpdateWithoutAlunosInput, turmasUncheckedUpdateWithoutAlunosInput>
  }

  export type turmasUpdateManyWithWhereWithoutAlunosInput = {
    where: turmasScalarWhereInput
    data: XOR<turmasUpdateManyMutationInput, turmasUncheckedUpdateManyWithoutTurmaInput>
  }

  export type turmasScalarWhereInput = {
    AND?: Enumerable<turmasScalarWhereInput>
    OR?: Enumerable<turmasScalarWhereInput>
    NOT?: Enumerable<turmasScalarWhereInput>
    id_turma?: IntFilter | number
    nome?: StringFilter | string
    codigo?: StringFilter | string
  }

  export type pontosUpsertWithWhereUniqueWithoutAlunosInput = {
    where: pontosWhereUniqueInput
    update: XOR<pontosUpdateWithoutAlunosInput, pontosUncheckedUpdateWithoutAlunosInput>
    create: XOR<pontosCreateWithoutAlunosInput, pontosUncheckedCreateWithoutAlunosInput>
  }

  export type pontosUpdateWithWhereUniqueWithoutAlunosInput = {
    where: pontosWhereUniqueInput
    data: XOR<pontosUpdateWithoutAlunosInput, pontosUncheckedUpdateWithoutAlunosInput>
  }

  export type pontosUpdateManyWithWhereWithoutAlunosInput = {
    where: pontosScalarWhereInput
    data: XOR<pontosUpdateManyMutationInput, pontosUncheckedUpdateManyWithoutPontosInput>
  }

  export type pontosScalarWhereInput = {
    AND?: Enumerable<pontosScalarWhereInput>
    OR?: Enumerable<pontosScalarWhereInput>
    NOT?: Enumerable<pontosScalarWhereInput>
    id_ponto?: IntFilter | number
    id_aluno?: IntFilter | number
    id_turma?: IntFilter | number
    qtd?: FloatNullableFilter | number | null
  }

  export type atividades_concluidasUpsertWithWhereUniqueWithoutAlunoInput = {
    where: atividades_concluidasWhereUniqueInput
    update: XOR<atividades_concluidasUpdateWithoutAlunoInput, atividades_concluidasUncheckedUpdateWithoutAlunoInput>
    create: XOR<atividades_concluidasCreateWithoutAlunoInput, atividades_concluidasUncheckedCreateWithoutAlunoInput>
  }

  export type atividades_concluidasUpdateWithWhereUniqueWithoutAlunoInput = {
    where: atividades_concluidasWhereUniqueInput
    data: XOR<atividades_concluidasUpdateWithoutAlunoInput, atividades_concluidasUncheckedUpdateWithoutAlunoInput>
  }

  export type atividades_concluidasUpdateManyWithWhereWithoutAlunoInput = {
    where: atividades_concluidasScalarWhereInput
    data: XOR<atividades_concluidasUpdateManyMutationInput, atividades_concluidasUncheckedUpdateManyWithoutAtividades_concluidasInput>
  }

  export type atividades_concluidasScalarWhereInput = {
    AND?: Enumerable<atividades_concluidasScalarWhereInput>
    OR?: Enumerable<atividades_concluidasScalarWhereInput>
    NOT?: Enumerable<atividades_concluidasScalarWhereInput>
    id_concluida?: IntFilter | number
    id_atividade?: IntFilter | number
    id_aluno?: IntFilter | number
    data_concluida?: DateTimeFilter | Date | string
    arquivo?: StringFilter | string
  }

  export type turmasCreateWithoutProfessoresInput = {
    nome: string
    codigo: string
    alunos?: alunosCreateNestedManyWithoutTurmaInput
    atividades?: atividadesCreateNestedManyWithoutTurmaInput
    pontos?: pontosCreateNestedManyWithoutTurmaInput
    premios?: premiosCreateNestedManyWithoutTurmaInput
  }

  export type turmasUncheckedCreateWithoutProfessoresInput = {
    id_turma?: number
    nome: string
    codigo: string
    alunos?: alunosUncheckedCreateNestedManyWithoutTurmaInput
    atividades?: atividadesUncheckedCreateNestedManyWithoutTurmaInput
    pontos?: pontosUncheckedCreateNestedManyWithoutTurmaInput
    premios?: premiosUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type turmasCreateOrConnectWithoutProfessoresInput = {
    where: turmasWhereUniqueInput
    create: XOR<turmasCreateWithoutProfessoresInput, turmasUncheckedCreateWithoutProfessoresInput>
  }

  export type turmasUpsertWithWhereUniqueWithoutProfessoresInput = {
    where: turmasWhereUniqueInput
    update: XOR<turmasUpdateWithoutProfessoresInput, turmasUncheckedUpdateWithoutProfessoresInput>
    create: XOR<turmasCreateWithoutProfessoresInput, turmasUncheckedCreateWithoutProfessoresInput>
  }

  export type turmasUpdateWithWhereUniqueWithoutProfessoresInput = {
    where: turmasWhereUniqueInput
    data: XOR<turmasUpdateWithoutProfessoresInput, turmasUncheckedUpdateWithoutProfessoresInput>
  }

  export type turmasUpdateManyWithWhereWithoutProfessoresInput = {
    where: turmasScalarWhereInput
    data: XOR<turmasUpdateManyMutationInput, turmasUncheckedUpdateManyWithoutTurmaInput>
  }

  export type turmasCreateWithoutAtividadesInput = {
    nome: string
    codigo: string
    professores?: professoresCreateNestedManyWithoutTurmaInput
    alunos?: alunosCreateNestedManyWithoutTurmaInput
    pontos?: pontosCreateNestedManyWithoutTurmaInput
    premios?: premiosCreateNestedManyWithoutTurmaInput
  }

  export type turmasUncheckedCreateWithoutAtividadesInput = {
    id_turma?: number
    nome: string
    codigo: string
    professores?: professoresUncheckedCreateNestedManyWithoutTurmaInput
    alunos?: alunosUncheckedCreateNestedManyWithoutTurmaInput
    pontos?: pontosUncheckedCreateNestedManyWithoutTurmaInput
    premios?: premiosUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type turmasCreateOrConnectWithoutAtividadesInput = {
    where: turmasWhereUniqueInput
    create: XOR<turmasCreateWithoutAtividadesInput, turmasUncheckedCreateWithoutAtividadesInput>
  }

  export type atividades_concluidasCreateWithoutAtividadeInput = {
    data_concluida: Date | string
    arquivo: string
    aluno: alunosCreateNestedOneWithoutAtividades_concluidasInput
  }

  export type atividades_concluidasUncheckedCreateWithoutAtividadeInput = {
    id_concluida?: number
    id_aluno: number
    data_concluida: Date | string
    arquivo: string
  }

  export type atividades_concluidasCreateOrConnectWithoutAtividadeInput = {
    where: atividades_concluidasWhereUniqueInput
    create: XOR<atividades_concluidasCreateWithoutAtividadeInput, atividades_concluidasUncheckedCreateWithoutAtividadeInput>
  }

  export type atividades_concluidasCreateManyAtividadeInputEnvelope = {
    data: Enumerable<atividades_concluidasCreateManyAtividadeInput>
    skipDuplicates?: boolean
  }

  export type turmasUpsertWithoutAtividadesInput = {
    update: XOR<turmasUpdateWithoutAtividadesInput, turmasUncheckedUpdateWithoutAtividadesInput>
    create: XOR<turmasCreateWithoutAtividadesInput, turmasUncheckedCreateWithoutAtividadesInput>
  }

  export type turmasUpdateWithoutAtividadesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    professores?: professoresUpdateManyWithoutTurmaNestedInput
    alunos?: alunosUpdateManyWithoutTurmaNestedInput
    pontos?: pontosUpdateManyWithoutTurmaNestedInput
    premios?: premiosUpdateManyWithoutTurmaNestedInput
  }

  export type turmasUncheckedUpdateWithoutAtividadesInput = {
    id_turma?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    professores?: professoresUncheckedUpdateManyWithoutTurmaNestedInput
    alunos?: alunosUncheckedUpdateManyWithoutTurmaNestedInput
    pontos?: pontosUncheckedUpdateManyWithoutTurmaNestedInput
    premios?: premiosUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type atividades_concluidasUpsertWithWhereUniqueWithoutAtividadeInput = {
    where: atividades_concluidasWhereUniqueInput
    update: XOR<atividades_concluidasUpdateWithoutAtividadeInput, atividades_concluidasUncheckedUpdateWithoutAtividadeInput>
    create: XOR<atividades_concluidasCreateWithoutAtividadeInput, atividades_concluidasUncheckedCreateWithoutAtividadeInput>
  }

  export type atividades_concluidasUpdateWithWhereUniqueWithoutAtividadeInput = {
    where: atividades_concluidasWhereUniqueInput
    data: XOR<atividades_concluidasUpdateWithoutAtividadeInput, atividades_concluidasUncheckedUpdateWithoutAtividadeInput>
  }

  export type atividades_concluidasUpdateManyWithWhereWithoutAtividadeInput = {
    where: atividades_concluidasScalarWhereInput
    data: XOR<atividades_concluidasUpdateManyMutationInput, atividades_concluidasUncheckedUpdateManyWithoutAtividades_concluidasInput>
  }

  export type atividadesCreateWithoutAtividades_concluidasInput = {
    titulo: string
    descricao: string
    prazo: Date | string
    pontos_conclusao?: number
    turma: turmasCreateNestedOneWithoutAtividadesInput
  }

  export type atividadesUncheckedCreateWithoutAtividades_concluidasInput = {
    id_atividade?: number
    id_turma: number
    titulo: string
    descricao: string
    prazo: Date | string
    pontos_conclusao?: number
  }

  export type atividadesCreateOrConnectWithoutAtividades_concluidasInput = {
    where: atividadesWhereUniqueInput
    create: XOR<atividadesCreateWithoutAtividades_concluidasInput, atividadesUncheckedCreateWithoutAtividades_concluidasInput>
  }

  export type alunosCreateWithoutAtividades_concluidasInput = {
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
    turma?: turmasCreateNestedManyWithoutAlunosInput
    pontos?: pontosCreateNestedManyWithoutAlunosInput
  }

  export type alunosUncheckedCreateWithoutAtividades_concluidasInput = {
    id_aluno?: number
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
    turma?: turmasUncheckedCreateNestedManyWithoutAlunosInput
    pontos?: pontosUncheckedCreateNestedManyWithoutAlunosInput
  }

  export type alunosCreateOrConnectWithoutAtividades_concluidasInput = {
    where: alunosWhereUniqueInput
    create: XOR<alunosCreateWithoutAtividades_concluidasInput, alunosUncheckedCreateWithoutAtividades_concluidasInput>
  }

  export type atividadesUpsertWithoutAtividades_concluidasInput = {
    update: XOR<atividadesUpdateWithoutAtividades_concluidasInput, atividadesUncheckedUpdateWithoutAtividades_concluidasInput>
    create: XOR<atividadesCreateWithoutAtividades_concluidasInput, atividadesUncheckedCreateWithoutAtividades_concluidasInput>
  }

  export type atividadesUpdateWithoutAtividades_concluidasInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    pontos_conclusao?: IntFieldUpdateOperationsInput | number
    turma?: turmasUpdateOneRequiredWithoutAtividadesNestedInput
  }

  export type atividadesUncheckedUpdateWithoutAtividades_concluidasInput = {
    id_atividade?: IntFieldUpdateOperationsInput | number
    id_turma?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    pontos_conclusao?: IntFieldUpdateOperationsInput | number
  }

  export type alunosUpsertWithoutAtividades_concluidasInput = {
    update: XOR<alunosUpdateWithoutAtividades_concluidasInput, alunosUncheckedUpdateWithoutAtividades_concluidasInput>
    create: XOR<alunosCreateWithoutAtividades_concluidasInput, alunosUncheckedCreateWithoutAtividades_concluidasInput>
  }

  export type alunosUpdateWithoutAtividades_concluidasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
    turma?: turmasUpdateManyWithoutAlunosNestedInput
    pontos?: pontosUpdateManyWithoutAlunosNestedInput
  }

  export type alunosUncheckedUpdateWithoutAtividades_concluidasInput = {
    id_aluno?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
    turma?: turmasUncheckedUpdateManyWithoutAlunosNestedInput
    pontos?: pontosUncheckedUpdateManyWithoutAlunosNestedInput
  }

  export type professoresCreateWithoutTurmaInput = {
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
  }

  export type professoresUncheckedCreateWithoutTurmaInput = {
    id_prof?: number
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
  }

  export type professoresCreateOrConnectWithoutTurmaInput = {
    where: professoresWhereUniqueInput
    create: XOR<professoresCreateWithoutTurmaInput, professoresUncheckedCreateWithoutTurmaInput>
  }

  export type alunosCreateWithoutTurmaInput = {
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
    pontos?: pontosCreateNestedManyWithoutAlunosInput
    atividades_concluidas?: atividades_concluidasCreateNestedManyWithoutAlunoInput
  }

  export type alunosUncheckedCreateWithoutTurmaInput = {
    id_aluno?: number
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
    pontos?: pontosUncheckedCreateNestedManyWithoutAlunosInput
    atividades_concluidas?: atividades_concluidasUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type alunosCreateOrConnectWithoutTurmaInput = {
    where: alunosWhereUniqueInput
    create: XOR<alunosCreateWithoutTurmaInput, alunosUncheckedCreateWithoutTurmaInput>
  }

  export type atividadesCreateWithoutTurmaInput = {
    titulo: string
    descricao: string
    prazo: Date | string
    pontos_conclusao?: number
    atividades_concluidas?: atividades_concluidasCreateNestedManyWithoutAtividadeInput
  }

  export type atividadesUncheckedCreateWithoutTurmaInput = {
    id_atividade?: number
    titulo: string
    descricao: string
    prazo: Date | string
    pontos_conclusao?: number
    atividades_concluidas?: atividades_concluidasUncheckedCreateNestedManyWithoutAtividadeInput
  }

  export type atividadesCreateOrConnectWithoutTurmaInput = {
    where: atividadesWhereUniqueInput
    create: XOR<atividadesCreateWithoutTurmaInput, atividadesUncheckedCreateWithoutTurmaInput>
  }

  export type atividadesCreateManyTurmaInputEnvelope = {
    data: Enumerable<atividadesCreateManyTurmaInput>
    skipDuplicates?: boolean
  }

  export type pontosCreateWithoutTurmaInput = {
    qtd?: number | null
    alunos: alunosCreateNestedOneWithoutPontosInput
  }

  export type pontosUncheckedCreateWithoutTurmaInput = {
    id_ponto?: number
    id_aluno: number
    qtd?: number | null
  }

  export type pontosCreateOrConnectWithoutTurmaInput = {
    where: pontosWhereUniqueInput
    create: XOR<pontosCreateWithoutTurmaInput, pontosUncheckedCreateWithoutTurmaInput>
  }

  export type pontosCreateManyTurmaInputEnvelope = {
    data: Enumerable<pontosCreateManyTurmaInput>
    skipDuplicates?: boolean
  }

  export type premiosCreateWithoutTurmaInput = {
    descricao: string
    pontos_requeridos: number
  }

  export type premiosUncheckedCreateWithoutTurmaInput = {
    id_premio?: number
    descricao: string
    pontos_requeridos: number
  }

  export type premiosCreateOrConnectWithoutTurmaInput = {
    where: premiosWhereUniqueInput
    create: XOR<premiosCreateWithoutTurmaInput, premiosUncheckedCreateWithoutTurmaInput>
  }

  export type premiosCreateManyTurmaInputEnvelope = {
    data: Enumerable<premiosCreateManyTurmaInput>
    skipDuplicates?: boolean
  }

  export type professoresUpsertWithWhereUniqueWithoutTurmaInput = {
    where: professoresWhereUniqueInput
    update: XOR<professoresUpdateWithoutTurmaInput, professoresUncheckedUpdateWithoutTurmaInput>
    create: XOR<professoresCreateWithoutTurmaInput, professoresUncheckedCreateWithoutTurmaInput>
  }

  export type professoresUpdateWithWhereUniqueWithoutTurmaInput = {
    where: professoresWhereUniqueInput
    data: XOR<professoresUpdateWithoutTurmaInput, professoresUncheckedUpdateWithoutTurmaInput>
  }

  export type professoresUpdateManyWithWhereWithoutTurmaInput = {
    where: professoresScalarWhereInput
    data: XOR<professoresUpdateManyMutationInput, professoresUncheckedUpdateManyWithoutProfessoresInput>
  }

  export type professoresScalarWhereInput = {
    AND?: Enumerable<professoresScalarWhereInput>
    OR?: Enumerable<professoresScalarWhereInput>
    NOT?: Enumerable<professoresScalarWhereInput>
    id_prof?: IntFilter | number
    nome?: StringFilter | string
    email?: StringFilter | string
    senha?: StringFilter | string
    nivel_de_acesso?: StringNullableFilter | string | null
  }

  export type alunosUpsertWithWhereUniqueWithoutTurmaInput = {
    where: alunosWhereUniqueInput
    update: XOR<alunosUpdateWithoutTurmaInput, alunosUncheckedUpdateWithoutTurmaInput>
    create: XOR<alunosCreateWithoutTurmaInput, alunosUncheckedCreateWithoutTurmaInput>
  }

  export type alunosUpdateWithWhereUniqueWithoutTurmaInput = {
    where: alunosWhereUniqueInput
    data: XOR<alunosUpdateWithoutTurmaInput, alunosUncheckedUpdateWithoutTurmaInput>
  }

  export type alunosUpdateManyWithWhereWithoutTurmaInput = {
    where: alunosScalarWhereInput
    data: XOR<alunosUpdateManyMutationInput, alunosUncheckedUpdateManyWithoutAlunosInput>
  }

  export type alunosScalarWhereInput = {
    AND?: Enumerable<alunosScalarWhereInput>
    OR?: Enumerable<alunosScalarWhereInput>
    NOT?: Enumerable<alunosScalarWhereInput>
    id_aluno?: IntFilter | number
    nome?: StringFilter | string
    email?: StringFilter | string
    senha?: StringFilter | string
    nivel_de_acesso?: StringNullableFilter | string | null
  }

  export type atividadesUpsertWithWhereUniqueWithoutTurmaInput = {
    where: atividadesWhereUniqueInput
    update: XOR<atividadesUpdateWithoutTurmaInput, atividadesUncheckedUpdateWithoutTurmaInput>
    create: XOR<atividadesCreateWithoutTurmaInput, atividadesUncheckedCreateWithoutTurmaInput>
  }

  export type atividadesUpdateWithWhereUniqueWithoutTurmaInput = {
    where: atividadesWhereUniqueInput
    data: XOR<atividadesUpdateWithoutTurmaInput, atividadesUncheckedUpdateWithoutTurmaInput>
  }

  export type atividadesUpdateManyWithWhereWithoutTurmaInput = {
    where: atividadesScalarWhereInput
    data: XOR<atividadesUpdateManyMutationInput, atividadesUncheckedUpdateManyWithoutAtividadesInput>
  }

  export type atividadesScalarWhereInput = {
    AND?: Enumerable<atividadesScalarWhereInput>
    OR?: Enumerable<atividadesScalarWhereInput>
    NOT?: Enumerable<atividadesScalarWhereInput>
    id_atividade?: IntFilter | number
    id_turma?: IntFilter | number
    titulo?: StringFilter | string
    descricao?: StringFilter | string
    prazo?: DateTimeFilter | Date | string
    pontos_conclusao?: IntFilter | number
  }

  export type pontosUpsertWithWhereUniqueWithoutTurmaInput = {
    where: pontosWhereUniqueInput
    update: XOR<pontosUpdateWithoutTurmaInput, pontosUncheckedUpdateWithoutTurmaInput>
    create: XOR<pontosCreateWithoutTurmaInput, pontosUncheckedCreateWithoutTurmaInput>
  }

  export type pontosUpdateWithWhereUniqueWithoutTurmaInput = {
    where: pontosWhereUniqueInput
    data: XOR<pontosUpdateWithoutTurmaInput, pontosUncheckedUpdateWithoutTurmaInput>
  }

  export type pontosUpdateManyWithWhereWithoutTurmaInput = {
    where: pontosScalarWhereInput
    data: XOR<pontosUpdateManyMutationInput, pontosUncheckedUpdateManyWithoutPontosInput>
  }

  export type premiosUpsertWithWhereUniqueWithoutTurmaInput = {
    where: premiosWhereUniqueInput
    update: XOR<premiosUpdateWithoutTurmaInput, premiosUncheckedUpdateWithoutTurmaInput>
    create: XOR<premiosCreateWithoutTurmaInput, premiosUncheckedCreateWithoutTurmaInput>
  }

  export type premiosUpdateWithWhereUniqueWithoutTurmaInput = {
    where: premiosWhereUniqueInput
    data: XOR<premiosUpdateWithoutTurmaInput, premiosUncheckedUpdateWithoutTurmaInput>
  }

  export type premiosUpdateManyWithWhereWithoutTurmaInput = {
    where: premiosScalarWhereInput
    data: XOR<premiosUpdateManyMutationInput, premiosUncheckedUpdateManyWithoutPremiosInput>
  }

  export type premiosScalarWhereInput = {
    AND?: Enumerable<premiosScalarWhereInput>
    OR?: Enumerable<premiosScalarWhereInput>
    NOT?: Enumerable<premiosScalarWhereInput>
    id_premio?: IntFilter | number
    id_turma?: IntFilter | number
    descricao?: StringFilter | string
    pontos_requeridos?: FloatFilter | number
  }

  export type turmasCreateWithoutPremiosInput = {
    nome: string
    codigo: string
    professores?: professoresCreateNestedManyWithoutTurmaInput
    alunos?: alunosCreateNestedManyWithoutTurmaInput
    atividades?: atividadesCreateNestedManyWithoutTurmaInput
    pontos?: pontosCreateNestedManyWithoutTurmaInput
  }

  export type turmasUncheckedCreateWithoutPremiosInput = {
    id_turma?: number
    nome: string
    codigo: string
    professores?: professoresUncheckedCreateNestedManyWithoutTurmaInput
    alunos?: alunosUncheckedCreateNestedManyWithoutTurmaInput
    atividades?: atividadesUncheckedCreateNestedManyWithoutTurmaInput
    pontos?: pontosUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type turmasCreateOrConnectWithoutPremiosInput = {
    where: turmasWhereUniqueInput
    create: XOR<turmasCreateWithoutPremiosInput, turmasUncheckedCreateWithoutPremiosInput>
  }

  export type turmasUpsertWithoutPremiosInput = {
    update: XOR<turmasUpdateWithoutPremiosInput, turmasUncheckedUpdateWithoutPremiosInput>
    create: XOR<turmasCreateWithoutPremiosInput, turmasUncheckedCreateWithoutPremiosInput>
  }

  export type turmasUpdateWithoutPremiosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    professores?: professoresUpdateManyWithoutTurmaNestedInput
    alunos?: alunosUpdateManyWithoutTurmaNestedInput
    atividades?: atividadesUpdateManyWithoutTurmaNestedInput
    pontos?: pontosUpdateManyWithoutTurmaNestedInput
  }

  export type turmasUncheckedUpdateWithoutPremiosInput = {
    id_turma?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    professores?: professoresUncheckedUpdateManyWithoutTurmaNestedInput
    alunos?: alunosUncheckedUpdateManyWithoutTurmaNestedInput
    atividades?: atividadesUncheckedUpdateManyWithoutTurmaNestedInput
    pontos?: pontosUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type alunosCreateWithoutPontosInput = {
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
    turma?: turmasCreateNestedManyWithoutAlunosInput
    atividades_concluidas?: atividades_concluidasCreateNestedManyWithoutAlunoInput
  }

  export type alunosUncheckedCreateWithoutPontosInput = {
    id_aluno?: number
    nome: string
    email: string
    senha: string
    nivel_de_acesso?: string | null
    turma?: turmasUncheckedCreateNestedManyWithoutAlunosInput
    atividades_concluidas?: atividades_concluidasUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type alunosCreateOrConnectWithoutPontosInput = {
    where: alunosWhereUniqueInput
    create: XOR<alunosCreateWithoutPontosInput, alunosUncheckedCreateWithoutPontosInput>
  }

  export type turmasCreateWithoutPontosInput = {
    nome: string
    codigo: string
    professores?: professoresCreateNestedManyWithoutTurmaInput
    alunos?: alunosCreateNestedManyWithoutTurmaInput
    atividades?: atividadesCreateNestedManyWithoutTurmaInput
    premios?: premiosCreateNestedManyWithoutTurmaInput
  }

  export type turmasUncheckedCreateWithoutPontosInput = {
    id_turma?: number
    nome: string
    codigo: string
    professores?: professoresUncheckedCreateNestedManyWithoutTurmaInput
    alunos?: alunosUncheckedCreateNestedManyWithoutTurmaInput
    atividades?: atividadesUncheckedCreateNestedManyWithoutTurmaInput
    premios?: premiosUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type turmasCreateOrConnectWithoutPontosInput = {
    where: turmasWhereUniqueInput
    create: XOR<turmasCreateWithoutPontosInput, turmasUncheckedCreateWithoutPontosInput>
  }

  export type alunosUpsertWithoutPontosInput = {
    update: XOR<alunosUpdateWithoutPontosInput, alunosUncheckedUpdateWithoutPontosInput>
    create: XOR<alunosCreateWithoutPontosInput, alunosUncheckedCreateWithoutPontosInput>
  }

  export type alunosUpdateWithoutPontosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
    turma?: turmasUpdateManyWithoutAlunosNestedInput
    atividades_concluidas?: atividades_concluidasUpdateManyWithoutAlunoNestedInput
  }

  export type alunosUncheckedUpdateWithoutPontosInput = {
    id_aluno?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
    turma?: turmasUncheckedUpdateManyWithoutAlunosNestedInput
    atividades_concluidas?: atividades_concluidasUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type turmasUpsertWithoutPontosInput = {
    update: XOR<turmasUpdateWithoutPontosInput, turmasUncheckedUpdateWithoutPontosInput>
    create: XOR<turmasCreateWithoutPontosInput, turmasUncheckedCreateWithoutPontosInput>
  }

  export type turmasUpdateWithoutPontosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    professores?: professoresUpdateManyWithoutTurmaNestedInput
    alunos?: alunosUpdateManyWithoutTurmaNestedInput
    atividades?: atividadesUpdateManyWithoutTurmaNestedInput
    premios?: premiosUpdateManyWithoutTurmaNestedInput
  }

  export type turmasUncheckedUpdateWithoutPontosInput = {
    id_turma?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    professores?: professoresUncheckedUpdateManyWithoutTurmaNestedInput
    alunos?: alunosUncheckedUpdateManyWithoutTurmaNestedInput
    atividades?: atividadesUncheckedUpdateManyWithoutTurmaNestedInput
    premios?: premiosUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type pontosCreateManyAlunosInput = {
    id_ponto?: number
    id_turma: number
    qtd?: number | null
  }

  export type atividades_concluidasCreateManyAlunoInput = {
    id_concluida?: number
    id_atividade: number
    data_concluida: Date | string
    arquivo: string
  }

  export type turmasUpdateWithoutAlunosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    professores?: professoresUpdateManyWithoutTurmaNestedInput
    atividades?: atividadesUpdateManyWithoutTurmaNestedInput
    pontos?: pontosUpdateManyWithoutTurmaNestedInput
    premios?: premiosUpdateManyWithoutTurmaNestedInput
  }

  export type turmasUncheckedUpdateWithoutAlunosInput = {
    id_turma?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    professores?: professoresUncheckedUpdateManyWithoutTurmaNestedInput
    atividades?: atividadesUncheckedUpdateManyWithoutTurmaNestedInput
    pontos?: pontosUncheckedUpdateManyWithoutTurmaNestedInput
    premios?: premiosUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type turmasUncheckedUpdateManyWithoutTurmaInput = {
    id_turma?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
  }

  export type pontosUpdateWithoutAlunosInput = {
    qtd?: NullableFloatFieldUpdateOperationsInput | number | null
    turma?: turmasUpdateOneRequiredWithoutPontosNestedInput
  }

  export type pontosUncheckedUpdateWithoutAlunosInput = {
    id_ponto?: IntFieldUpdateOperationsInput | number
    id_turma?: IntFieldUpdateOperationsInput | number
    qtd?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type pontosUncheckedUpdateManyWithoutPontosInput = {
    id_ponto?: IntFieldUpdateOperationsInput | number
    id_turma?: IntFieldUpdateOperationsInput | number
    qtd?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type atividades_concluidasUpdateWithoutAlunoInput = {
    data_concluida?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivo?: StringFieldUpdateOperationsInput | string
    atividade?: atividadesUpdateOneRequiredWithoutAtividades_concluidasNestedInput
  }

  export type atividades_concluidasUncheckedUpdateWithoutAlunoInput = {
    id_concluida?: IntFieldUpdateOperationsInput | number
    id_atividade?: IntFieldUpdateOperationsInput | number
    data_concluida?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivo?: StringFieldUpdateOperationsInput | string
  }

  export type atividades_concluidasUncheckedUpdateManyWithoutAtividades_concluidasInput = {
    id_concluida?: IntFieldUpdateOperationsInput | number
    id_atividade?: IntFieldUpdateOperationsInput | number
    data_concluida?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivo?: StringFieldUpdateOperationsInput | string
  }

  export type turmasUpdateWithoutProfessoresInput = {
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    alunos?: alunosUpdateManyWithoutTurmaNestedInput
    atividades?: atividadesUpdateManyWithoutTurmaNestedInput
    pontos?: pontosUpdateManyWithoutTurmaNestedInput
    premios?: premiosUpdateManyWithoutTurmaNestedInput
  }

  export type turmasUncheckedUpdateWithoutProfessoresInput = {
    id_turma?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    alunos?: alunosUncheckedUpdateManyWithoutTurmaNestedInput
    atividades?: atividadesUncheckedUpdateManyWithoutTurmaNestedInput
    pontos?: pontosUncheckedUpdateManyWithoutTurmaNestedInput
    premios?: premiosUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type atividades_concluidasCreateManyAtividadeInput = {
    id_concluida?: number
    id_aluno: number
    data_concluida: Date | string
    arquivo: string
  }

  export type atividades_concluidasUpdateWithoutAtividadeInput = {
    data_concluida?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivo?: StringFieldUpdateOperationsInput | string
    aluno?: alunosUpdateOneRequiredWithoutAtividades_concluidasNestedInput
  }

  export type atividades_concluidasUncheckedUpdateWithoutAtividadeInput = {
    id_concluida?: IntFieldUpdateOperationsInput | number
    id_aluno?: IntFieldUpdateOperationsInput | number
    data_concluida?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivo?: StringFieldUpdateOperationsInput | string
  }

  export type atividadesCreateManyTurmaInput = {
    id_atividade?: number
    titulo: string
    descricao: string
    prazo: Date | string
    pontos_conclusao?: number
  }

  export type pontosCreateManyTurmaInput = {
    id_ponto?: number
    id_aluno: number
    qtd?: number | null
  }

  export type premiosCreateManyTurmaInput = {
    id_premio?: number
    descricao: string
    pontos_requeridos: number
  }

  export type professoresUpdateWithoutTurmaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type professoresUncheckedUpdateWithoutTurmaInput = {
    id_prof?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type professoresUncheckedUpdateManyWithoutProfessoresInput = {
    id_prof?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type alunosUpdateWithoutTurmaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
    pontos?: pontosUpdateManyWithoutAlunosNestedInput
    atividades_concluidas?: atividades_concluidasUpdateManyWithoutAlunoNestedInput
  }

  export type alunosUncheckedUpdateWithoutTurmaInput = {
    id_aluno?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
    pontos?: pontosUncheckedUpdateManyWithoutAlunosNestedInput
    atividades_concluidas?: atividades_concluidasUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type alunosUncheckedUpdateManyWithoutAlunosInput = {
    id_aluno?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel_de_acesso?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type atividadesUpdateWithoutTurmaInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    pontos_conclusao?: IntFieldUpdateOperationsInput | number
    atividades_concluidas?: atividades_concluidasUpdateManyWithoutAtividadeNestedInput
  }

  export type atividadesUncheckedUpdateWithoutTurmaInput = {
    id_atividade?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    pontos_conclusao?: IntFieldUpdateOperationsInput | number
    atividades_concluidas?: atividades_concluidasUncheckedUpdateManyWithoutAtividadeNestedInput
  }

  export type atividadesUncheckedUpdateManyWithoutAtividadesInput = {
    id_atividade?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    pontos_conclusao?: IntFieldUpdateOperationsInput | number
  }

  export type pontosUpdateWithoutTurmaInput = {
    qtd?: NullableFloatFieldUpdateOperationsInput | number | null
    alunos?: alunosUpdateOneRequiredWithoutPontosNestedInput
  }

  export type pontosUncheckedUpdateWithoutTurmaInput = {
    id_ponto?: IntFieldUpdateOperationsInput | number
    id_aluno?: IntFieldUpdateOperationsInput | number
    qtd?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type premiosUpdateWithoutTurmaInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    pontos_requeridos?: FloatFieldUpdateOperationsInput | number
  }

  export type premiosUncheckedUpdateWithoutTurmaInput = {
    id_premio?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pontos_requeridos?: FloatFieldUpdateOperationsInput | number
  }

  export type premiosUncheckedUpdateManyWithoutPremiosInput = {
    id_premio?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pontos_requeridos?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}